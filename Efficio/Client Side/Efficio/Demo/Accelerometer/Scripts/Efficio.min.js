define('Human Input Recognition and Processing/ActiveGestureDictionary', [], function () {
    var ActiveGesturesDictionary = {}

    function GetActiveGestureDictionary() {
        if (!ActiveGesturesDictionary) {
            ActiveGesturesDictionary == {};
        }

        return ActiveGesturesDictionary;
    }

    function RetrieveEntry(trackingType, gestureName, dictionary, side) {
        var entry;
        var agd = GetActiveGestureDictionary();

        if (dictionary) {
            if (!agd[trackingType][dictionary]) {
                agd[trackingType][dictionary] = {};
            }

            if (side) {
                if (!agd[trackingType][dictionary][side]) {
                    agd[trackingType][dictionary][side] = {};
                }

                entry = agd[trackingType][dictionary][side][gestureName];
            }
            else {
                entry = agd[trackingType][dictionary][gestureName];
            }
        }
        else {
            entry = agd[trackingType][gestureName];
        }

        return entry;
    }

    function AddEntry(entry, trackingType, gestureName, dictionary, side) {
        var agd = GetActiveGestureDictionary();

        if (dictionary) {
            if (side) {
                agd[trackingType][dictionary][side][gestureName] = entry;
            }
            else {
                agd[trackingType][dictionary][gestureName] = entry;
            }
        }
        else {
            agd[trackingType][gestureName] = entry;
        }
    }

    function CreateOrUpdateEntry(trackingType, gestureName, dictionary, side) {
        var entry = RetrieveEntry(trackginType, gestureName, dictionary, side);

        if (!entry) {
            entry = {
                // Time properties
                StartTime: new Date(),
                EndTime: null,
                GestureDuration: function () {
                    var endTime = this.EndTime || new Date();

                    return Math.abs(this.StartTime - endTime)
                },

                // Fire count properties
                FireCount: 0,
                FirstFire: function () { return this.FireCount === 0 }
            }

            AddEntry(entry, trackingType, gestureName, dictionary, side);
        }
        else {
            entry.FireCount++;
        }

        return entry;
    }

    function DeleteEntry(trakcingType, gestureName, dictionary, side) {
        var agd = GetActiveGestureDictionary();

        if (dictionary) {
            if (agd[trackingType][dictionary]) {
                if (side) {
                    if (agd[trackingType][dictionary][side]) {
                        if (gestureName) {
                            agd[trackingType][dictionary][side][gestureName] = null;
                        }
                        else {
                            agd[trackingType][dictionary][side] = null;
                        }
                    }
                }
                else {
                    if (gestureName) {
                        agd[trackingType][dictionary][gestureName] = null;
                    }
                    else {
                        agd[trackingType][dictionary] = null;
                    }
                }
            }
        }
        else {
            agd[trackingType][gestureName] = null;
        }
    }

    return {
        GetActiveGesturesDictionary: GetActiveGestureDictionary,
        CreateOrUpdateEntry: CreateOrUpdateEntry,
        RetrieveEntry: RetrieveEntry,
        DeleteEntry: DeleteEntry
    }
});

define('Human Input Recognition and Processing/CustomGestureLibrariesAccess', ['postal'], function (bus) {
    var source = 'Custom Gesture Libraries';
    var ActiveGesturesDictionaryCopy = {};

    function LoadCustomGestures() {
        // Custom Gestures created by the user will be loaded here
    }

    function DetectCustomGestures(data, envelope) {
        var libraryName = 'custom library 1';
        var gestureName = 'my custom gesture';
        var gestureData = 'my custom gesture data';

        // If custom gesture is detected
        if (data.input === 'BVH representation of a custom gesture') {

            bus.publish({
                channel: "Input.Processed.Custom." + libraryName,
                topic: gestureName,
                source: source,
                data: gestureData
            });
        }
    }

    return {
        Initialize: function (ActiveGesturesDictionary) {
            ActiveGesturesDictionaryCopy = ActiveGesturesDictionary;
        },
        ProcessInput: function (data, envelope) {

            // Where input is processed and Custom Gestures are published on the channel
            DetectCustomGestures(data, envelope);
        }
    }
})
;
define('Helpers/Math', [], function () {

    function GetAngleBetweenVectors(vector1, vector2) {
        a = {
            x: vector1[0],
            y: vector1[1],
            z: vector1[2]
        }

        b = {
            x: vector2[0],
            y: hand.arm.direction()[1],
            z: hand.arm.direction()[2]
        }
        var axb = vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2];
        var vector1Length = Math.sqrt(vector1[0] * vector1[0] + vector1[1] * vector1[1] + vector1[2] * vector1[2]);
        var vector2Length = Math.sqrt(vector2[0] * vector2[0] + vector2[1] * vector2[1] + vector2[2] * vector2[2]);

        return Math.acos(axb / (vector1Length * vector2Length)) * (180 / Math.PI)
    }

    function DistanceBetweenTwoPoints(point1, point2) {
        point1[2] = point1[2] || 0;
        point2[2] = point2[2] || 0;

        return Math.sqrt((point2[0] - point1[0]) * (point2[0] - point1[0]) + (point2[1] - point1[1]) * (point2[1] - point1[1]) + (point2[2] - point1[2]) * (point2[2] - point1[2]))
    }

    function MidpointBetweenTwoPoints(point1, point2) {
        point1[2] = point1[2] || 0;
        point2[2] = point2[2] || 0;

        return [(point2[0] - point1[0]) / 2, (point2[1] - point1[1]) / 2, (point2[2] - point1[2]) / 2];
    }

    function Velocity(point1, point2, time) {
        return (DistanceBetweenTwoPoints(point1, point2) / (time / 1000)) + ' mm/sec';
    }

    return {
        GetAngleBetweenVectors: GetAngleBetweenVectors,
        DistanceBetweenTwoPoints: DistanceBetweenTwoPoints,
        MidpointBetweenTwoPoints: MidpointBetweenTwoPoints,
        Velocity: Velocity
    }
})
;
define('Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper', ['Helpers/Math'], function (math) {
    var configuration = {
        ExtensionAngle: 30,
        FlexionAngle: 30,
        SupinationMeasure: 145,
        PronationMeasure: {
            Min: -35,
            Max: 35
        },
        UlnarDeviationMeasure: .5,
        RadialDeviationMeasure: -.2,
    };

    function Configure(config) {
        configuration.ExtensionMeasure == config.ExtensionMeasure || configuration.ExtensionMeasure;
        configuration.FlexionMeasure == config.FlexionMeasure || configuration.FlexionMeasure;
        configuration.SupinationMeasure == config.SupinationMeasure || configuration.SupinationMeasure;
        configuration.UlnarDeviationMeasure == config.UlnarDeviationMeasure || configuration.UlnarDeviationMeasure;
        configuration.RadialDeviationMeasure == config.RadialDeviationMeasure || configuration.RadialDeviationMeasure;
    }

    function GetSide(hand) {
        return hand.type === 'right' ? 'Right' : 'Left';
    }

    function GetAngle(hand) {
        return hand.direction[1];
    }

    function Neutral(hand) {
        var neutral;

        if (!Supination(hand) && !Pronation(hand) && !HyperPronation(hand)) {
            neutral = {};
        }

        return neutral;
    }

    function Extension(hand) {
        var extension;
        var angle = ExtensionAngle(hand);

        if (angle > configuration.ExtensionAngle) {
            extension = {
                angle: angle
            }
        }

        return extension;
    }

    function ExtensionAngle(hand) {
        var angleCorrector = 1;
        var measure = hand.roll() * (180 / Math.PI);

        if (GetSide(hand) === 'Right') {
            measure = -measure;

            if (measure > 0) {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
        }
        else {
            if (measure > 0) {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
        }

        var angle = math.GetAngleBetweenVectors(hand.direction, hand.arm.direction());

        return angle * angleCorrector;
    }

    function Flexion(hand) {
        var flexion;
        var angle = FlexionAngle(hand);

        if (angle > configuration.FlexionAngle) {
            flexion = {
                TBD: angle
            }
        }

        return flexion;
    }

    function FlexionAngle(hand) {
        var angleCorrector = 1;
        var measure = hand.roll() * (180 / Math.PI);

        if (GetSide(hand) === 'Right') {
            measure = -measure;

            if (measure > 0) {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
        }
        else {
            if (measure > 0) {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
        }

        var angle = math.GetAngleBetweenVectors(hand.direction, hand.arm.direction());

        return angle * angleCorrector;
    }

    function Supination(hand) {
        var supination;
        var measure = hand.roll() * (180 / Math.PI);
        measure = GetSide(hand) === 'Right' ? -measure : measure;

        if (measure > configuration.SupinationMeasure) {
            supination = {
                TBD: measure
            }
        }

        return supination;
    }

    function Pronation(hand) {
        var pronation;
        var measure = hand.roll() * (180 / Math.PI);
        measure = GetSide(hand) === 'Right' ? -measure : measure;

        if (measure > configuration.PronationMeasure.Min && measure < configuration.PronationMeasure.Max) {
            pronation = {
                TBD: measure
            }
        }

        return pronation;
    }

    function HyperPronation(hand) {
        var pronation;
        var measure = hand.roll() * (180 / Math.PI);
        measure = GetSide(hand) === 'Right' ? -measure : measure;

        if (measure < configuration.PronationMeasure.Min) {
            pronation = {
                TBD: measure
            }
        }

        return pronation;
    }

    function UlnarDeviation(hand) {
        var deviation;
        var measure = GetSide(hand) === 'Right' ? hand.direction[0] - hand.arm.direction()[0] : -1 * hand.direction[0] - (-1) * hand.arm.direction()[0];

        if (measure > configuration.UlnarDeviationMeasure) {
            deviation = {
                TBD: measure
            }
        }

        return deviation;
    }

    function RadialDeviation(hand) {
        var deviation;
        var measure = GetSide(hand) === 'Right' ? hand.direction[0] - hand.arm.direction()[0] : -1 * hand.direction[0] - (-1) * hand.arm.direction()[0];

        if (measure < configuration.RadialDeviationMeasure) {
            deviation = {
                TBD: measure
            }
        }

        return deviation;
    }


    return {
        Configure: Configure,
        GetSide: GetSide,
        GetAngle: GetAngle,
        Neutral: Neutral,
        Extension: Extension,
        ExtensionAngle: ExtensionAngle,
        Flexion: Flexion,
        FlexionAngle: FlexionAngle,
        Supination: Supination,
        Pronation: Pronation,
        HyperPronation: HyperPronation,
        UlnarDeviation: UlnarDeviation,
        RadialDeviation: RadialDeviation
    }
})
;
define('Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper', [], function () {
    var fingerCountLabelsMap = ["Zero", "One", "Two", "Three", "Four", "Five"];
    var fingerNameLabelMap = ["Thumb", "Index", "Middle", "Ring", "Pinky"];

    function GetExtendedFingers(hand) {
        return hand.fingers.filter(function (finger) {
            return finger.extended;
        });
    }

    function GetExtendedFingersIndicies(hand) {
        return GetExtendedFingers(hand).map(function (finger) {
            return finger.type
        });
    }

    function GetFingerLabel(fingerIndex) {
        return fingerNameLabelMap[fingerIndex];
    }

    function GetExtendedFingersCount(hand) {
        return GetExtendedFingers(hand).length;
    }

    function GetExtendedFingersCountLabel(hand) {
        return fingerCountLabelsMap[GetExtendedFingersCount(hand)];
    }

    function AreRequisiteFingersExtended(neededFingersArray, hand) {
        var extendedFingers = GetExtendedFingersIndicies(hand);

        return extendedFingers.filter(function (finger) {
            return neededFingersArray.indexOf(finger) != -1
        }).length === neededFingersArray.length && extendedFingers.length === neededFingersArray.length;
    }

    function DistanceBetweenFingers(finger1, finger2) {
        var finger1Tip = finger1.tipPosition;
        var finger2Tip = finger2.tipPosition;
        var x2 = finger1Tip[0];
        var y2 = finger1Tip[1];
        var z2 = finger1Tip[2];
        var x1 = finger2Tip[0];
        var y1 = finger2Tip[1];
        var z1 = finger2Tip[2];

        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1))
    }

    return {
        GetExtendedFingers: GetExtendedFingers,
        GetExtendedFingersIndicies: GetExtendedFingersIndicies,
        GetFingerLabel: GetFingerLabel,
        GetExtendedFingersCount: GetExtendedFingersCount,
        GetExtendedFingersCountLabel: GetExtendedFingersCountLabel,
        AreRequisiteFingersExtended: AreRequisiteFingersExtended,
        DistanceBetweenFingers: DistanceBetweenFingers
    }
})
;
define('Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandPositionDetection', ['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper'], function (bus, hh, fh) {
    var source = 'Efficio Gesture Grimoire';
    var name = 'One Hand Gesture Detector';
    var dictionary = 'OneHandPosition';
    var trackingType = 'Hands';
    var side;
    var oneHandPositionDetector;

    /*
          Name:           {Side} Hand Detected
   
          Outputs:        RightHandDetected
                          LeftHandDetected
           
          Description:    Informs consumer how many fingers fingers are extended and on which hand 
       */
    function SideHandDetected(hand, data) {
        var gestureName = side + 'HandDetected';

        //TODO: Clear all entries in agd
        var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

        bus.publish({
            channel: "Input.Processed.Efficio",
            topic: gestureName,
            source: source,
            data: {
                input: data,
                hand: hand,
                gestureInformation: gestureInformation
            }
        });
    }

    /*
          Name:           {Side} Hand {Count} Fingers Extended
   
          Outputs:        RightHandZeroFingersExtended
                          RightHandOneFingersExtended
                          RightHandTwoFingersExtended
                          RightHandThreeFingersExtended
                          RightHandFourFingersExtended
                          RightHandFiveFingersExtended
                          LeftHandZeroFingersExtended
                          LeftHandOneFingersExtended
                          LeftHandTwoFingersExtended
                          LeftHandThreeFingersExtended
                          LeftHandFourFingersExtended
                          LeftHandFiveFingersExtended
           
          Description:    Informs consumer how many fingers fingers are extended and on which hand 
       */
    function SideHandCountFingersExtended(hand, data) {
        var extendedFingerCountLabel = fh.GetExtendedFingersCountLabel(hand);
        var extendedFingersIndicies = fh.GetExtendedFingersIndicies(hand);

        //TODO: Clear all entries in agd and add new entry

        bus.publish({
            channel: "Input.Processed.Efficio",
            topic: side + 'Hand' + extendedFingerCountLabel + 'FingersExtended',
            source: source,
            data: {
                input: data,
                hand: hand,
                extendedFingers: extendedFingersIndicies
            }
        });
    }; // END {Side} Hand {Count} Fingers Extended

    /*
   Name:           {Side} Hand {Finger} Extended

   Outputs:        RightHandThumbFingerExtended
                   RightHandIndexFingerExtended
                   RightHandMiddleFingerExtended
                   RightHandRingFingerExtended
                   RightHandPinkyFingerExtended
                   LeftHandThumbFingerExtended
                   LeftHandIndexFingerExtended
                   LeftHandMiddleFingerExtended
                   LeftHandRingFingerExtended
                   LeftHandPinkyFingerExtended
   
   Description:    Informs consumer which fingers are extended and on which hand 
*/
    function SideHandFingerDetected(hand, data) {
        hand.fingers.forEach(function (finger) {
            var fingerName = fh.GetFingerLabel(finger.type);
            var gestureName = side + 'Hand' + fingerName + 'FingerExtended'

            if (finger.extended) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        finger: finger.type,
                        gestureInformation: gestureInformation
                    }
                });
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
            }
        });
    }; // END {Side} Hand {Finger} 

    /*
    Name:           {Side} Hand Flexion Detected

    Outputs:        RightHandFlexion
                    LeftHandFlexion
*/
    function SideHandFlexionDetected(hand, data) {
        var gestureName = side + 'HandFlexion'
        var flexion = hh.Flexion(hand);
        if (flexion) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            if (gestureInformation.FireCount > 10) {
                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        flexion: flexion,
                        gestureInformation: gestureInformation
                    }
                });
            }
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Flexion

    /*
    Name:           {Side} Hand Extension Detected

    Outputs:        RightHandExtension
                    LeftHandExtension
*/
    function SideHandExtensionDetected(hand, data) {
        var gestureName = side + 'HandExtension'
        var extension = hh.Extension(hand);
        if (extension) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            if (gestureInformation.FireCount > 10) {
                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        extension: extension,
                        gestureInformation: gestureInformation
                    }
                });
            }
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Extension

    /*
    Name:           {Side} Hand Radial Deviation

    Outputs:        RightHandRadialDeviation
                    LeftHandRadialDeviation
*/
    function SideHandRadialDeviation(hand, data) {
        var gestureName = side + 'HandRadialDeviation'
        var deviation = hh.RadialDeviation(hand);
        if (deviation) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    deviation: deviation,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Radial Deviation

    /*
           Name:           {Side} Hand Ulnar Deviation

           Outputs:        RightHandUlnarDeviation
                           LeftHandUlnarDeviation
       */
    function SideHandUlnarDeviation(hand, data) {
        var gestureName = side + 'HandUlnarDeviation'
        var deviation = hh.UlnarDeviation(hand);
        if (deviation) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    deviation: deviation,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Ulnar Deviation

    /*
            Name:           {Side} Hand Supenation

            Outputs:        RightHandSupenation
                            LeftHandSupenation
        */
    function SideHandSupenation(hand, data) {
        var gestureName = side + 'HandSupenation'
        var supenation = hh.Supination(hand);
        if (supenation) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    supenation: supenation,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Supenation

    /*
            Name:           {Side} Hand Pronation

            Outputs:        RightHandPronation
                            LeftHandPronation
        */
    function SideHandPronation(hand, data) {
        var gestureName = side + 'HandPronation'
        var pronation = hh.Pronation(hand);
        if (pronation) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    pronation: pronation,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Pronation

    /*
           Name:           {Side} Hand Hyper Pronation

           Outputs:        RightHandHyperPronation
                           LeftHandHyperPronation
       */
    function SideHandHyperPronation(hand, data) {
        var gestureName = side + 'HandHyperPronation'
        var pronation = hh.HyperPronation(hand);
        if (pronation) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    pronation: pronation,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Hyper Pronation

    /*
           Name:           {Side} Hand Neutral

           Outputs:        RightHandNeutral
                           LeftHandNeutral
        */
    function SideHandNeutral(hand, data) {
        var gestureName = side + 'HandNeutral'
        var neutral = hh.Neutral(hand);
        if (neutral) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    neutral: neutral,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Neutral

    function Pinch(hand, data) {
        for (var i = 0; i < hand.fingers.length - 1; i++) {
            for (var j = i + 1; j < hand.fingers.length; j++) {
                var gestureName = side + 'Hand' + fh.GetFingerLabel(i) + fh.GetFingerLabel(j) + 'Pinch';
                var pinchDistance = fh.DistanceBetweenFingers(hand.fingers[i], hand.fingers[j]);

                if (pinchDistance < 23) {
                    var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

                    bus.publish({
                        channel: "Input.Processed.Efficio",
                        topic: gestureName,
                        source: source,
                        data: {
                            input: data,
                            hand: hand,
                            pinchDistance: pinchDistance,
                            pinchFingersIndicies: [i, j],
                            gestureInformation: gestureInformation
                        }
                    });
                }
                else {
                    ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
                }
            }
        }
    };// END Pinch

    function ThumbsUp(hand, data) {
        var gestureName = side + 'ThumbsUp';
        if (hh.Neutral(hand) && fh.AreRequisiteFingersExtended([0], hand)) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END ThumbsUp

    function ProcessInput(data, hand, ActiveGesturesDictionary) {
        // Hand information
        (function HandInformation() {
            side = hh.GetSide(hand);
        })();

        if (!oneHandPositionDetector) {
            oneHandPositionDetector = { Name: name };
            oneHandPositionDetector.SideHandDetected = SideHandDetected;
            oneHandPositionDetector.SideHandCountFingersExtended = SideHandCountFingersExtended;
            oneHandPositionDetector.SideHandFingerDetected = SideHandFingerDetected;
            oneHandPositionDetector.SideHandFlexionDetected = SideHandFlexionDetected;
            oneHandPositionDetector.SideHandExtensionDetected = SideHandExtensionDetected;
            oneHandPositionDetector.SideHandRadialDeviation = SideHandRadialDeviation;
            oneHandPositionDetector.SideHandUlnarDeviation = SideHandUlnarDeviation;
            oneHandPositionDetector.SideHandSupenation = SideHandSupenation;
            oneHandPositionDetector.SideHandPronation = SideHandPronation;
            oneHandPositionDetector.SideHandHyperPronation = SideHandHyperPronation;
            oneHandPositionDetector.SideHandNeutral = SideHandNeutral;
            oneHandPositionDetector.Pinch = Pinch;
            oneHandPositionDetector.ThumbsUp = ThumbsUp;
        }

        oneHandPositionDetector.forEach(function (position) {
            position(hand, data);
        });

        return oneHandPositionDetector;
    }

    return {
        ProcessInput: ProcessInput
    }
});

define('Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandGestureDetection', ['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper', 'Helpers/Math'], function (bus, hh, fh, math) {
    var source = 'Efficio Gesture Grimoire';
    var name = 'One Hand Gesture Detector';
    var dictionary = 'OneHandGesture';
    var trackingType = 'Hands';
    var side;
    var oneHandGestureDetector;

    function SideHandSwipe(hand) {
        var gestureName = side + 'HandSwipe';
        var isExecuting = false;
        var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary);

        if (hh.Extension(hand) && hh.Neutral(hand)) {
            if (typeof gestureInformation.ExtensionFramesCount === 'undefined') {
                gestureInformation.ExtensionFramesCount = 0;
                gestureInformation.PalmStartPosition = hand.palmPosition;
                gestureInformation.MiddleFingerStartPosition = hand.middleFinger.tipPosition;
                gestureInformation.StartFrame = hand.frame;

                setTimeout(function () {
                    isExecuting = false;
                }, 2000);
            } else {
                gestureInformation.ExtensionFramesCount++;
            }

            isExecuting = true;
        } else {
            if (gestureInformation.ExtensionFramesCount > 10 && hh.Neutral(hand)) {
                if (typeof gestureInformation.NeutralFramesCount === 'undefined') {
                    gestureInformation.NeutralFramesCount = 0;
                } else {
                    gestureInformation.NeutralFramesCount++;
                }

                isExecuting = true;
            }
        }

        if (gestureInformation.ExtensionFramesCount > 10 && gestureInformation.NeutralFramesCount > 10 && hh.Flexion(hand) && !gestureInformation.Fired) {
            gestureInformation.EndTime = new Date();
            gestureInformation.PalmEndPosition = hand.palmPosition;
            gestureInformation.MiddleFingerEndPosition = hand.middleFinger.tipPosition;
            gestureInformation.EndFrame = hand.frame;
            gestureInformation.SwipeVelocity = math.Velocity(gestureInformation.MiddleFingerStartPosition, gestureInformation.MiddleFingerEndPosition, gestureInformation.GestureDuration());
            gestureInformation.Fired = true;

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureInformation: gestureInformation
                }
            });

            setTimeout(function () {
                ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
            }, 250);
        }

        if (!isExecuting) {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    }

    function ProcessInput(data, hand, ActiveGesturesDictionary) {
        // Hand information
        (function HandInformation() {
            side = hh.GetSide(hand);
        })();

        if (!oneHandGestureDetector) {
            oneHandGestureDetector = { Name: name };
            oneHandGestureDetector.SideHandSwipe = SideHandSwipe;
        }

        oneHandGestureDetector.forEach(function (position) {
            position(hand);
        });

        return oneHandGestureDetector;
    }

    return {
        ProcessInput: ProcessInput
    }
});

define('Human Input Recognition and Processing/Hand Gestures/Two Hand Gestures/TwoHandPositionDetection', ['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper', 'Helpers/Math'], function (bus, hh, fh, math) {
    var source = 'Efficio Gesture Grimoire';
    var dictionary = 'TwoHandPosition';
    var FireCountMinimum = 15;
    var trackingType = 'Hands';
    var twoHandsGestureDetector;

    function BothHandsNeutral(data) {
        var hands = data.hands;
        var gestureName = 'BothHandsNeutral'
        var neutrals = [hh.Neutral(hands[0]), hh.Neutral(hands[1])]

        if (neutrals[0] && neutrals[1]) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trakcingType, gestureName, dictionary);

            if (gestureInformation.FireCount > FireCountMinimum) {
                gestureInformation.distance = math.DistanceBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);
                gestureInformation.midpoint = math.MidpointBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        neutrals: neutrals,
                        gestureInformation: gestureInformation
                    }
                });
            }
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trakcingType, gestureName, dictionary);
        }
    };// END Both Hands Neutral

    function BothHandsPronation(data) {
        var gestureName = 'BothHandsPronation'
        var pronations = [hh.Pronation(hands[0]), hh.Pronation(hands[1])]

        if (pronations[0] && pronations[1]) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary);

            if (gestureInformation.FireCount > FireCountMinimum) {
                gestureInformation.distance = math.DistanceBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);
                gestureInformation.midpoint = math.MidpointBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        neutrals: pronations,
                    }
                });
            }
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary);
        }
    };// END Both Hand Pronation

    function ProcessInput(data, ActiveGesturesDictionary) {
        if (!twoHandsGestureDetector) {
            twoHandsGestureDetector = { Name: name };
            twoHandsGestureDetector.BothHandsNeutral = BothHandsNeutral;
            twoHandsGestureDetector.BothHandsPronation = BothHandsPronation;
        }

        twoHandsGestureDetector.forEach(function (gesture) {
            position(data);
        });

        return twoHandsGestureDetector;
    }

    return {
        ProcessInput: ProcessInput
    }
});

define('Human Input Recognition and Processing/Hand Gestures/HandGestureDetectionHandler', ['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper'], function (bus, hh) {
    var source = 'Efficio Gesture Grimoire';
    var name = 'Efficio Hand Gesture Detection Handler';
    var channel = 'Input.Processed.Efficio';
    var trackingType = "Hands";
    var handGestureDetectionLibrary = { Name: name };

    function ProcessInput(data, ActiveGesturesDictionary) {
        // Check if there is any input and if the input contains hands
        if (data.input && data.input.hands) {

            var hands = data.input.hands;

            // Check if any hands are present
            (function NoHandsDetected() {
                var gestureName = 'NoHandsDetected'

                if (hands.length === 0) {
                    var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName)

                    bus.publish({
                        channel: channel,
                        topic: gestureName,
                        source: source,
                        data: {
                            message: 'No hands detected',
                            gestureInformation: gestureInformation
                        }
                    });

                    // Clear gesture dictionary for one and two hand gestures
                    ActiveGesturesDictionary.DeleteEntry(trackingType, null, 'OneHandPosition');
                    ActiveGesturesDictionary.DeleteEntry(trackingType, null, 'OneHandGesture');
                    ActiveGesturesDictionary.DeleteEntry(trackingType, null, 'TwoHandPositione');
                    ActiveGesturesDictionary.DeleteEntry(trackingType, null, 'TwoHandGesture');

                    // No need for processing any further
                    return;
                }
                else {
                    ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName);
                }
            })();

            // Detects each hand's presence independently
            if (hands.length > 0) {
                hands.forEach(function (hand) {
                    var gestureName = type + 'HandDetected';

                    // Send Message saying what hand was detected
                    var type = hand.type;
                    bus.publish({
                        channel: channel,
                        topic: gestureName,
                        source: source,
                        data: {
                            hand: hand
                        }
                    });

                    // Send data to the one hand position gesture detection libraries
                    require(['Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandPositionDetection'], function (ohgd) {
                        handGestureDetectionLibrary.OneHandPositionDetector = ohgd.ProcessInput(data, hand, ActiveGesturesDictionary);
                    });

                    // Send data to the one hand gesture detection library
                    require(['Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandGestureDetection'], function (ohgd) {
                        handGestureDetectionLibrary.OneHandGestureDetector = ohgd.ProcessInput(data, hand, ActiveGesturesDictionary);
                    });
                });
            }

            // Check if one hand is present
            (function OneHandDetected() {
                if (hands.length === 1) {
                    var side = hh.GetSide(hands[0]);
                    var gestureName = 'OneHandDetected'
                    var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName)

                    var oppositeHand = side === 'Right' ? 'Left' : 'Right'

                    // Clear other hand gesture dictionary entries
                    ActiveGesturesDictionary.DeleteEntry(trackingType, null, 'OneHandPosition', oppositeHand);
                    ActiveGesturesDictionary.DeleteEntry(trackingType, null, 'OneHandGesture', oppositeHand);

                    // Clear two hand gesture dictionary entries
                    ActiveGesturesDictionary.DeleteEntry(trackingType, null, 'TwoHandGesture');

                    // Send Message saying that a hand was detected
                    bus.publish({
                        channel: channel,
                        topic: gestureName,
                        source: source,
                        data: {
                            handCount: hands[0],
                            gestureInformation: gestureInformation
                        }
                    });
                }
                else {
                    ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName);
                }
            })();

            // Check if any hand present
            if (hands.length == 2) {
                (function TwoHandsDetected() {
                    if (hands.length === 2) {
                        var gestureName = 'TwoHandDetected'
                        var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName)

                        // Send Message saying that two hands were detected
                        bus.publish({
                            channel: channel,
                            topic: gestureName,
                            source: source,
                            data: {
                                gestureInformation: gestureInformation
                            }
                        });

                        // Send data to the two hand gesture detection library
                        require(['Human Input Recognition and Processing/Hand Gestures/Two Hand Gestures/TwoHandPositionDetection'], function (thgd) {
                            handGestureDetectionLibrary.TwoHandPositionDetector = thgd.ProcessInput(data, ActiveGesturesDictionary);
                        });
                    }
                    else {

                    }
                })();
            }
        }

        return handGestureDetectionLibrary;
    }


    return {
        ProcessInput: ProcessInput
    }
})
;
define('Human Input Recognition and Processing/EfficioGestureGrimoire', ['postal'], function (bus) {
    var source = 'Efficio Gesture Grimoire';
    var ActiveGesturesDictionary;
    var efficioGestureGrimoire = { Name: source };

    function DetectPredefinedGestures(data, envelope) {
        var trackingType = data.trackingType || '';

        switch (trackingType) {
            case 'Hands': {
                require(['Human Input Recognition and Processing/Hand Gestures/HandGestureDetectionHandler'], function (hgdh) {
                    efficioGestureGrimoire.HandProcessor = hgdh.ProcessInput(data, ActiveGesturesDictionary)
                });
                break;
            }
            case 'Body': {
                // Body tracking library here
                break;
            }
            case 'Head': {
                // Head tracking library here
                break;
            }
            case 'Brain': {
                // Brain tracking library here
                break;
            }
            case 'Sensor': {
                // Other sensory input library here
                break;
            }
        }

        return efficioGestureGrimoire;
    }



    return {
        Initialize: function (agd) {
            ActiveGesturesDictionary = agd;
        },

        ProcessInput: function (data, envelope) {
            DetectPredefinedGestures(data, envelope);
        }
    }
});

define('Human Input Recognition and Processing/HumanInputRecognitionAndProcessing', ['postal', 'Human Input Recognition and Processing/ActiveGestureDictionary'], function (bus, agd) {

    var hipr = {};

    function Initialize() {
        require(['Human Input Recognition and Processing/CustomGestureLibrariesAccess'], function (customGestureLibraries) {
            hipr.CustomGestureLibrary = customGestureLibraries.Initialize(agd);

            bus.subscribe({
                channel: "Input.Raw",
                topic: "*",
                callback: function (data, envelope) {
                    customGestureLibraries.ProcessInput(data, envelope);
                }
            });
        }), function (err) {
            bus.publish({
                channel: 'UserNotification',
                topic: 'Warn',
                source: source,
                data: {
                    message: 'No custom gesture library configured'
                }
            });
        };

        require(['Human Input Recognition and Processing/EfficioGestureGrimoire'], function (efficioGestureLibrary) {
            hipr.EfficioGestureLibrary = efficioGestureLibrary.Initialize(agd);

            bus.subscribe({
                channel: "Input.Raw",
                topic: "*",
                callback: function (data, envelope) {
                    efficioGestureLibrary.ProcessInput(data, envelope);
                }
            });
        });

        //require(['Human Input Recognition and Processing/EfficioAudioGrimoire'], function (efficioAudioGrimoire) {
        //    efficioAudioGrimoire.Initialize();

        //    bus.subscribe({
        //        channel: "Input.Audio.Raw",
        //        topic: "*",
        //        callback: function (data, envelope) {
        //            efficioAudioGrimoire.ProcessInput(data, envelope);
        //        }
        //    });
        //});

        return hipr;
    }

    return {
        Initialize: Initialize
    }
});

define('InternalScene', ['THREE'], function () {
    var scene = new THREE.Scene();

    return {
        Initialize: function () {

        },

        Scene: scene
    }
});

define('Asset Management and Inventory/AssetManager', ['postal', 'InternalScene'], function (bus, internalScene) {
    var source = "Efficio Asset Manager"

    function CreateAsset(asset) {
        bus.publish({
            channel: "UserNotification",
            topic: "AssetCreated",
            source: source,
            data: {
                message: "Asset created with data: " + asset
            }
        });

        internalScene.Scene.add(asset);
    };

    function CreateAssets(assets) {

    };

    function RetrieveAsset(assetID) {

    };

    function RetrieveAssets(assetIDs) {

    };

    function RetrieveAllAssets() {

    };

    function RetrieveAllAssetIDs() {

    };

    function UpdateAsset(asset) {
        var oldAsset = internalScene.Scene.getObjectById(asset.id);

        internalScene.Scene.remove(oldAsset);
        internalScene.Scene.add(asset);

        asset = internalScene.Scene.getObjectById(asset.id);

        bus.publish({
            channel: "UserNotification",
            topic: "AssetUpdated",
            source: source,
            data: {
                message: source + " - Asset Updated: \nID: " + asset.id + "\nPosition: (" + asset.position.x + " , " + asset.position.y + ", " + asset.position.z + ")" + "\nScale: (" + asset.scale.x + " , " + asset.scale.y + ", " + asset.scale.z + ")"
            }
        });
    };

    function UpdateAssets(assets) {

    };

    function DeleteAsset(assetID) {

    };

    function DeleteAssets(assetIDs) {

    };

    function DeleteAllAssets() {

    };

    function GetValueForProperty(property, data) {
        switch (property) {
            case "ClosestAsset":
                {
                    return GetClosestAsset(data);
                }
        }
    }

    function GetClosestAsset(data) {
        if (data.location === null) {
            bus.publish({
                channel: "Exception.Efficio",
                topic: "GetClosestAsset",
                source: source,
                data: {
                    message: "GetClosestAsset function requires location argument"
                }
            });
        }
        return "Asset closest to point (" + data.Location.x + ", " + data.Location.y + ", " + data.Location.z + ")"
    }

    return {
        Initialize: function () {
            if (typeof window != 'undefined') {
                //var http = new XMLHttpRequest();
                //http.open('HEAD', '/debug.html', false);
                //http.send();

                //if (http.status != 404) {
                //    var params = [
                //        'height=' + screen.height,
                //        'width=' + screen.width,
                //        'fullscreen=yes' // only works in IE, but here for completeness
                //    ].join(',');

                //    window.open('/debug.html', 'AMI Debugger', params);
                //}
            }
        },

        CreateAsset: CreateAsset,

        CreateAssets: CreateAssets,

        RetrieveAsset: RetrieveAsset,

        RetrieveAssets: RetrieveAssets,

        RetrieveAllAssets: RetrieveAllAssets,

        RetrieveAllAssetIDs: RetrieveAllAssetIDs,

        UpdateAsset: UpdateAsset,

        UpdateAssets: UpdateAssets,

        DeleteAsset: DeleteAsset,

        DeleteAssets: DeleteAssets,

        DeleteAllAssets: DeleteAllAssets,

        GetValueForProperty: GetValueForProperty,

    }
});

define('Constraints Engine/ConstraintsEngine', ['postal', 'Asset Management and Inventory/AssetManager'], function (bus, ami) {
    var source = "Efficio Constraints Engine";
    var violated = false;

    var subscriptions = new Array();

    function RegisterSubscriber(subscription) {
        subscriptions.push(subscription);
    }

    function CheckConstraints(data) {
        //if (violated) {
        //    console.log('Constraints violated, changes not reflected internally.')
        //}
        //else {
        //    console.log('Constraints not violated, changes reflected internally.')
        //}

        return true;
    }

    return {
        Initialize: function () {

        }
    };
});

define('Command Issuance and Control/CommandIssuanceAndControl', ['postal', 'Asset Management and Inventory/AssetManager'], function (bus, ami) {
    return {
        Initialize: function () {
            var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
            var ARGUMENT_NAMES = /([^\s,]+)/g;

            function getParamNames(func) {
                var fnStr = func.toString().replace(STRIP_COMMENTS, '');
                var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
                if (result === null)
                    result = [];
                return result;
            }

            ActionToFunctionMapping.ActionMappings.forEach(function (mapping) {
                bus.subscribe({
                    channel: mapping.Source,
                    topic: mapping.Topic,
                    callback: function (data, envelope) {
                        var func = mapping.Action;

                        if (typeof func != 'function') {
                            func = ActionToFunctionMapping.Bridge[mapping.Action];
                        }

                        // Get method parameters
                        var functionParameters = getParamNames(func);

                        var argMapping = {};

                        // Create args for function call
                        var args = [];

                        if (mapping.Arguments) {
                            functionParameters.forEach(function (param) {
                                var params = mapping.Arguments.filter(function (argument) {
                                    return argument.MapTo === param;
                                });

                                if (params.length > 0) {
                                    var value;

                                    if (params[0].Source && params[0].Source === 'AssetManager') {
                                        value = ami.GetValueForProperty(params[0].Name, data);
                                    }
                                    else {
                                        value = data[params[0].Name];
                                    }

                                    args.push(value);
                                }
                                else {
                                    args.push(null);
                                }
                            });
                        }
                        else {
                            args = [data];
                        }

                        func.apply(null, args);
                    }
                })
            });
        }
    };
});

define('Logging/SystemNotificationListener', ['postal'], function (bus) {
    return {
        Initialize: function () {
            bus.subscribe({
                channel: "SystemNotification",
                topic: "*",
                callback: function (data, envelope) {
                    console.log(envelope.topic + ": " + data.message);
                }
            });
        }
    }
});

define('Input/DeviceManager', ['postal'], function (bus) {
    var Efficio;
    var Devices = {};

    function Add(name, device) {
        Devices[name] = device;

        bus.publish({
            channel: 'Devices',
            topic: 'Added',
            source: name,
            data: {
                Name: name,
                Device: device
            }
        });
    }

    function Remove(name) {
        Devices[name] = null;

        bus.publish({
            channel: 'Devices',
            topic: 'Removed',
            source: name,
            data: {
                Name: name
            }
        });
    }

    function Initialize(Efficio) {
        return Devices;
    }

    return {
        Add: Add,
        Remove: Remove,
        Initialize: Initialize,
        Devices: Devices
    }
});

define('Metrics/Metrics', [], function () {
    var startTime;
    var framesSinceStart = 0;
    var Metrics = {};

    function incrementFrames() {
        framesSinceStart++;
        requestAnimationFrame(incrementFrames);
    }

    function AverageFPS() {
        return framesSinceStart / (UpTime() / 1000);
    }

    function UpTime() {
        return new Date() - startTime;
    }

    function Initialize() {
        Metrics.AverageFPS = AverageFPS;
        Metrics.UpTime = UpTime;

        return Metrics;
    }

    function Start() {
        startTime = new Date();

        if (window) {
            requestAnimationFrame(incrementFrames);
        }
    }

    return {
        Initialize: Initialize,
        Start: Start
    }
});

define('Input/LeapMotion/LeapMotion', ['postal', 'leapjs', 'Input/DeviceManager'], function (bus, Leap, deviceManager) {
    var source = 'Leap Motion';
    var trackingType = 'Hands';
    var controller;

    function configure(EfficioConfiguration) {
        var LeapConfiguration = EfficioConfiguration.Devices.LeapMotion;
        LeapConfiguration = {
            Host: LeapConfiguration.Host || 'localhost',
            Port: LeapConfiguration.Port || 6437,
            EnableGestures: LeapConfiguration.EnableGestures || false,
            FrameEventName: LeapConfiguration.FrameEventName || 'animationFrame',
            UseAllPlugins: LeapConfiguration.UseAllPlugins || false
        }

        return LeapConfiguration;
    }

    return {
        Initialize: function (LeapConfiguration) {

            // Load Configuration
            LeapConfiguration = configure(LeapConfiguration);

            // Create Controller
            controller = new Leap.Controller({
                host: LeapConfiguration.Host,
                port: LeapConfiguration.Port,
                enableGestures: LeapConfiguration.EnableGestures,
                frameEventName: LeapConfiguration.FrameEventName,
                useAllPlugins: LeapConfiguration.UseAllPlugins
            });

            // Register Leap Motion's native gesture recognition
            controller.on("gesture", function (gesture) {
                if (gesture.state == "stop") {
                    bus.publish({
                        channel: 'Input.Raw',
                        topic: 'Gesture',
                        source: source,
                        data: {
                            Name: gesture.type,
                            Gesture: gesture
                        }
                    });
                }
            });

            controller.connect();

            // Add Leap Motion to Device Manager
            deviceManager.Add(source, controller);
            deviceManager.Devices[source].IsConnected = function () {
                return controller.connected();
            }
        },

        Start: function () {

            // Listens for input from device
            controller.loop(function (frame) {
                if (frame.valid) {
                    bus.publish({
                        channel: 'Input.Raw',
                        topic: 'Leap',
                        source: source,
                        data: {
                            TrackingType: trackingType,
                            Input: frame
                        }
                    });
                }
            });
        }
    }
});

define('Input/Microphone/Microphone', ['postal', 'annyang', 'Input/DeviceManager'], function (bus, annyang, deviceManager) {

    var source = 'Microphone';

    function Initialize(LeapConfiguration) {

        if (typeof ActionToFunctionMapping.AudioCommands != 'undefined') {
            // Add our commands to annyang
            annyang.addCommands(ActionToFunctionMapping.AudioCommands);
        }

        // Add microphone to Device Manager
        deviceManager.Add(source, annyang);
    }

    function Start() {
        annyang.start();
    }

    return {
        Intitialize: Initialize,
        Start: Start
    }
});

define('Input/Accelerometer/Browser2', ['postal', 'Input/DeviceManager'], function (bus, deviceManager) {
    var source = "Accelerometer"
    var trackingType = 'Orientation';
    var started = false;

    function Initialize(EfficioConfiguration) {
        // Listen for orientation changes
        window.addEventListener('deviceorientation', function (eventData) {
            if (started) {
                bus.publish({
                    channel: 'Input.Raw',
                    topic: 'Device Orientation',
                    source: source,
                    data: {
                        TrackingType: trackingType,
                        DeviceOrientation: eventData
                    }
                });
            }
        }, false);
    }

    function Start() {
        started = true;
        deviceManager.Add(source, { started: true });
    }

    return {
        Initialize: Initialize,
        Start: Start
    }

})
;
define('Input/Geolocation/Browser', ['postal', 'Input/DeviceManager'], function (bus, deviceManager) {
    var source = "Geolocaiton"
    var trackingType = 'Location';
    var enabled = false;

    function getGeolocation() {
        navigator.geolocation.getCurrentPosition(publishPosition);
        window.requestAnimationFrame(getGeolocation);
    }

    function publishPosition(location) {
        bus.publish({
            channel: 'Input.Raw',
            topic: 'Location',
            source: source,
            data: {
                TrackingType: trackingType,
                Location: location
            }
        });
    }

    function Initialize(EfficioConfiguration) {
        if (window.navigator) {
            if (navigator.geolocation) {
                enabled = true;
            }
        }
    }

    function Start() {
        if (enabled) {
            window.requestAnimationFrame(getGeolocation);
        }
    }

    return {
        Initialize: Initialize,
        Start: Start
    }
});

define('Efficio', [
   'Human Input Recognition and Processing/HumanInputRecognitionAndProcessing',
   'Asset Management and Inventory/AssetManager',
   'Constraints Engine/ConstraintsEngine',
   'Command Issuance and Control/CommandIssuanceAndControl',
   'InternalScene',
   'Logging/SystemNotificationListener',
   'Input/DeviceManager',
   'Metrics/Metrics'
   //'Sequence Execution and Action Scheduling/CollisionDetectionAndGravitySimulation',
],

function (hirp, ami, constraintsEngine, comm, internalScene, sysNotificationListener, deviceManager, metrics) {
    var Efficio;

    function configure(EfficioConfiguration) {
        EfficioConfiguration.Devices = EfficioConfiguration.Devices || { Microphone: false, Kinect: false, LeapMotion: false };
        EfficioConfiguration.Debug = EfficioConfiguration.Debug || false;

        Efficio.Configuration = EfficioConfiguration;
    }

    return {
        Initialize: function (EfficioConfiguration) {

            if (typeof Efficio === 'undefined' || Efficio === null) {
                Efficio = {};
            }

            if (window && (window.Efficio === null || typeof window.Efficio === 'undefined')) {
                window.Efficio = Efficio
            }

            configure(EfficioConfiguration);

            Efficio.Metrics = metrics.Initialize();

            Efficio.HumanInputAndGestureRecognition = hirp.Initialize();
            ami.Initialize();
            constraintsEngine.Initialize();
            comm.Initialize();
            internalScene.Initialize();
            sysNotificationListener.Initialize();
            Efficio.DeviceManager = deviceManager.Initialize();

            if (EfficioConfiguration.Devices.LeapMotion) {
                require(['Input/LeapMotion/LeapMotion'], function (leap) {
                    leap.Initialize(EfficioConfiguration);
                    leap.Start();
                });
            }

            if (EfficioConfiguration.Devices.Microphone) {
                require(['Input/Microphone/Microphone'], function (microphone) {
                    microphone.Intitialize(EfficioConfiguration);
                    microphone.Start();
                });
            }

            if (window) {
                // Accelerometer
                require(['Input/Accelerometer/Browser2'], function (browser) {
                    browser.Initialize(EfficioConfiguration);
                    browser.Start();
                })

                require(['Input/Geolocation/Browser'], function (browser) {
                    browser.Initialize(EfficioConfiguration);
                    browser.Start();
                })
            }
        },
        Start: function () {
            metrics.Start();
        }
    }
});

if (typeof THREE === 'object') {
    define('THREE', function () { return THREE; });
}

if (typeof Leap === 'function') {
    define('leapjs', function () { return Leap; });
}

require(["Efficio"], function (Efficio) {
    Efficio.Initialize(EfficioConfiguration);
    Efficio.Start();
});

define("main", function () { });

