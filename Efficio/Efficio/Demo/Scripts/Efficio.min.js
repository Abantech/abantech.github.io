define('Message Bus/MessageBus',['postal'], function (bus) {
    return {
        Initialize: function () {
            // Any bus configuration here
        },
        Bus: bus
    }
});

﻿define('Human Input Recognition and Processing/ActiveGestureDictionary',[],function () {
    var ActiveGesturesDictionary = {}

    function GetActiveGestureDictionary() {
        if (!ActiveGesturesDictionary) {
            ActiveGesturesDictionary == {};
        }

        return ActiveGesturesDictionary;
    }

    function RetrieveEntry(gestureName, dictionary, side) {
        var entry;
        var agd = GetActiveGestureDictionary();

        if (dictionary) {
            if (!agd[dictionary]) {
                agd[dictionary] = {};
            }

            if (side) {
                if (!agd[dictionary][side]) {
                    agd[dictionary][side] = {};
                }

                entry = agd[dictionary][side][gestureName];
            }
            else {
                entry = agd[dictionary][gestureName];
            }
        }
        else {
            entry = agd[gestureName];
        }

        return entry;
    }

    function AddEntry(entry, gestureName, dictionary, side){
        var agd = GetActiveGestureDictionary();

        if (dictionary) {
            if (side) {
                agd[dictionary][side][gestureName] = entry;
            }
            else {
                agd[dictionary][gestureName] = entry;
            }
        }
        else {
            agd[gestureName] = entry;
        }
    }

    function CreateOrUpdateEntry(gestureName, dictionary, side) {
        var entry = RetrieveEntry(gestureName, dictionary, side);

        if (!entry) {
            entry = {
                // Time properties
                StartTime: new Date(),
                EndTime: null,
                GestureDuration: function () {
                    var endTime = this.EndTime || new Date();

                    return Math.abs(this.StartTime - endTime)
                },

                // Fire count properties
                FireCount: 0,
                FirstFire: function () { return this.FireCount === 0 }
            }

            AddEntry(entry, gestureName, dictionary, side);
        }
        else {
            entry.FireCount++;
        }

        return entry;
    }

    function DeleteEntry(gestureName, dictionary, side) {
        var agd = GetActiveGestureDictionary();

        if (dictionary) {
            if (agd[dictionary]) {
                if (side) {
                    if (agd[dictionary][side]) {
                        if (gestureName) {
                            agd[dictionary][side][gestureName] = null;
                        }
                        else {
                            agd[dictionary][side] = null;
                        }
                    }
                }
                else {
                    if (gestureName) {
                        agd[dictionary][gestureName] = null;
                    }
                    else {
                        agd[dictionary] = null;
                    }
                }
            }
        }
        else {
            agd[gestureName] = null;
        }
    }

    return {
        GetActiveGesturesDictionary: GetActiveGestureDictionary,
        CreateOrUpdateEntry: CreateOrUpdateEntry,
        RetrieveEntry: RetrieveEntry,
        DeleteEntry: DeleteEntry
    }
});

﻿define('Human Input Recognition and Processing/CustomGestureLibrariesAccess',['postal'], function (bus) {
    var source = 'Custom Gesture Libraries';
    var ActiveGesturesDictionaryCopy = {};

    function LoadCustomGestures() {
        // Custom Gestures created by the user will be loaded here
    }

    function DetectCustomGestures(data, envelope) {
        var libraryName = 'custom library 1';
        var gestureName = 'my custom gesture';
        var gestureData = 'my custom gesture data';

        // If custom gesture is detected
        if (data.input === 'BVH representation of a custom gesture') {

            bus.publish({
                channel: "Input.Processed.Custom." + libraryName,
                topic: gestureName,
                source: source,
                data: gestureData
            });
        }
    }

    return {
        Initialize: function (ActiveGesturesDictionary) {
            ActiveGesturesDictionaryCopy = ActiveGesturesDictionary;
        },
        ProcessInput: function (data, envelope) {

            // Where input is processed and Custom Gestures are published on the channel
            DetectCustomGestures(data, envelope);
        }
    }
})
;
﻿define('Helpers/Math',[],function () {

    function GetAngleBetweenVectors(vector1, vector2)
    {
        a = {
            x: vector1[0],
            y: vector1[1],
            z: vector1[2]
        }

        b = {
            x: vector2[0],
            y: hand.arm.direction()[1],
            z: hand.arm.direction()[2]
        }
        var axb = vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2];
        var vector1Length = Math.sqrt(vector1[0] * vector1[0] + vector1[1] * vector1[1] + vector1[2] * vector1[2]);
        var vector2Length = Math.sqrt(vector2[0] * vector2[0] + vector2[1] * vector2[1] + vector2[2] * vector2[2]);

        return Math.acos(axb / (vector1Length * vector2Length)) * (180 / Math.PI)
    }

    function DistanceBetweenTwoPoints(point1, point2) {
        point1[2] = point1[2] || 0;
        point2[2] = point2[2] || 0;

        return Math.sqrt((point2[0] - point1[0]) * (point2[0] - point1[0]) + (point2[1] - point1[1]) * (point2[1] - point1[1]) + (point2[2] - point1[2]) * (point2[2] - point1[2]))
    }

    function MidpointBetweenTwoPoints(point1, point2) {
        point1[2] = point1[2] || 0;
        point2[2] = point2[2] || 0;

        return [(point2[0] - point1[0]) / 2, (point2[1] - point1[1]) / 2, (point2[2] - point1[2]) / 2];
    }

    function Velocity(point1, point2, time) {
        return (DistanceBetweenTwoPoints(point1, point2) / (time / 1000)) + ' mm/sec' ;
    }

    return {
        GetAngleBetweenVectors: GetAngleBetweenVectors,
        DistanceBetweenTwoPoints: DistanceBetweenTwoPoints,
        MidpointBetweenTwoPoints: MidpointBetweenTwoPoints,
        Velocity: Velocity
    }
})
;
﻿define('Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper',['Helpers/Math'], function (math) {
    var configuration = {
        ExtensionAngle: 30,
        FlexionAngle: 30,
        SupinationMeasure: 145,
        PronationMeasure: {
            Min: -35,
            Max: 35
        },
        UlnarDeviationMeasure: .5,
        RadialDeviationMeasure: -.2,
    };

    function Configure(config) {
        configuration.ExtensionMeasure == config.ExtensionMeasure || configuration.ExtensionMeasure;
        configuration.FlexionMeasure == config.FlexionMeasure || configuration.FlexionMeasure;
        configuration.SupinationMeasure == config.SupinationMeasure || configuration.SupinationMeasure;
        configuration.UlnarDeviationMeasure == config.UlnarDeviationMeasure || configuration.UlnarDeviationMeasure;
        configuration.RadialDeviationMeasure == config.RadialDeviationMeasure || configuration.RadialDeviationMeasure;
    }

    function GetSide(hand) {
        return hand.type === 'right' ? 'Right' : 'Left';
    }

    function GetAngle(hand) {
        return hand.direction[1];
    }

    function Neutral(hand) {
        var neutral;

        if (!Supination(hand) && !Pronation(hand) && !HyperPronation(hand)) {
            neutral = {};
        }

        return neutral;
    }

    function Extension(hand) {
        var extension;
        var angle = ExtensionAngle(hand);

        if (angle > configuration.ExtensionAngle) {
            extension = {
                angle: angle
            }
        }

        return extension;
    }

    function ExtensionAngle(hand) {
        var angleCorrector = 1;
        var measure = hand.roll() * (180 / Math.PI);

        if (GetSide(hand) === 'Right') {
            measure = -measure;

            if (measure > 0) {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
        }
        else {
            if (measure > 0) {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
        }

        var angle = math.GetAngleBetweenVectors(hand.direction, hand.arm.direction());

        return angle * angleCorrector;
    }

    function Flexion(hand) {
        var flexion;
        var angle = FlexionAngle(hand);

        if (angle > configuration.FlexionAngle) {
            flexion = {
                TBD: angle
            }
        }

        return flexion;
    }

    function FlexionAngle(hand) {
        var angleCorrector = 1;
        var measure = hand.roll() * (180 / Math.PI);

        if (GetSide(hand) === 'Right') {
            measure = -measure;

            if (measure > 0) {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
        }
        else {
            if (measure > 0) {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
        }

        var angle = math.GetAngleBetweenVectors(hand.direction, hand.arm.direction());

        return angle * angleCorrector;
    }

    function Supination(hand) {
        var supination;
        var measure = hand.roll() * (180 / Math.PI);
        measure = GetSide(hand) === 'Right' ? -measure : measure;

        if (measure > configuration.SupinationMeasure) {
            supination = {
                TBD: measure
            }
        }

        return supination;
    }

    function Pronation(hand) {
        var pronation;
        var measure = hand.roll() * (180 / Math.PI);
        measure = GetSide(hand) === 'Right' ? -measure : measure;

        if (measure > configuration.PronationMeasure.Min && measure < configuration.PronationMeasure.Max) {
            pronation = {
                TBD: measure
            }
        }

        return pronation;
    }

    function HyperPronation(hand) {
        var pronation;
        var measure = hand.roll() * (180 / Math.PI);
        measure = GetSide(hand) === 'Right' ? -measure : measure;

        if (measure < configuration.PronationMeasure.Min) {
            pronation = {
                TBD: measure
            }
        }

        return pronation;
    }

    function UlnarDeviation(hand) {
        var deviation;
        var measure = GetSide(hand) === 'Right' ? hand.direction[0] - hand.arm.direction()[0] : -1 * hand.direction[0] - (-1) * hand.arm.direction()[0];

        if (measure > configuration.UlnarDeviationMeasure) {
            deviation = {
                TBD: measure
            }
        }

        return deviation;
    }

    function RadialDeviation(hand) {
        var deviation;
        var measure = GetSide(hand) === 'Right' ? hand.direction[0] - hand.arm.direction()[0] : -1 * hand.direction[0] - (-1) * hand.arm.direction()[0];

        if (measure < configuration.RadialDeviationMeasure) {
            deviation = {
                TBD: measure
            }
        }

        return deviation;
    }


    return {
        Configure: Configure,
        GetSide: GetSide,
        GetAngle: GetAngle,
        Neutral: Neutral,
        Extension: Extension,
        ExtensionAngle: ExtensionAngle,
        Flexion: Flexion,
        FlexionAngle: FlexionAngle,
        Supination: Supination,
        Pronation: Pronation,
        HyperPronation: HyperPronation,
        UlnarDeviation: UlnarDeviation,
        RadialDeviation: RadialDeviation
    }
})
;
﻿define('Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper',[],function () {
    var fingerCountLabelsMap = ["Zero", "One", "Two", "Three", "Four", "Five"];
    var fingerNameLabelMap = ["Thumb", "Index", "Middle", "Ring", "Pinky"];

    function GetExtendedFingers(hand){
        return hand.fingers.filter(function (finger) {
            return finger.extended;
        });
    }

    function GetExtendedFingersIndicies(hand) {
        return GetExtendedFingers(hand).map(function (finger) {
            return finger.type
        });
    }

    function GetFingerLabel(fingerIndex) {
        return fingerNameLabelMap[fingerIndex];
    }

    function GetExtendedFingersCount(hand) {
        return GetExtendedFingers(hand).length;
    }

    function GetExtendedFingersCountLabel(hand) {
        return fingerCountLabelsMap[GetExtendedFingersCount(hand)];
    }

    function AreRequisiteFingersExtended(neededFingersArray, hand) {
        var extendedFingers = GetExtendedFingersIndicies(hand);

        return extendedFingers.filter(function (finger) {
            return neededFingersArray.indexOf(finger) != -1
        }).length === neededFingersArray.length && extendedFingers.length === neededFingersArray.length;
    }
    
    function DistanceBetweenFingers(finger1, finger2) {
        var finger1Tip = finger1.tipPosition;
        var finger2Tip = finger2.tipPosition;
        var x2 = finger1Tip[0];
        var y2 = finger1Tip[1];
        var z2 = finger1Tip[2];
        var x1 = finger2Tip[0];
        var y1 = finger2Tip[1];
        var z1 = finger2Tip[2];

        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1))
    }

    return {
        GetExtendedFingers: GetExtendedFingers,
        GetExtendedFingersIndicies: GetExtendedFingersIndicies,
        GetFingerLabel: GetFingerLabel,
        GetExtendedFingersCount: GetExtendedFingersCount,
        GetExtendedFingersCountLabel: GetExtendedFingersCountLabel,
        AreRequisiteFingersExtended: AreRequisiteFingersExtended,
        DistanceBetweenFingers: DistanceBetweenFingers
    }
})
;
﻿define('Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandPositionDetection',['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper'], function (bus, hh, fh) {
    function ProcessInput(data, hand, ActiveGesturesDictionary) {
        var source = 'Efficio Gesture Grimoire';
        var dictionary = 'OneHandPosition';
        var side;

        // Hand information
        (function HandInformation() {
            side = hh.GetSide(hand);
        })();

        /*
          Name:           {Side} Hand Detected
   
          Outputs:        RightHandDetected
                          LeftHandDetected
           
          Description:    Informs consumer how many fingers fingers are extended and on which hand 
       */
        (function SideHandCountFingersExtended() {
            var gestureName = side + 'HandDetected';
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureInformation: gestureInformation
                }
            });
        })();

        /*
          Name:           {Side} Hand {Count} Fingers Extended
   
          Outputs:        RightHandZeroFingersExtended
                          RightHandOneFingersExtended
                          RightHandTwoFingersExtended
                          RightHandThreeFingersExtended
                          RightHandFourFingersExtended
                          RightHandFiveFingersExtended
                          LeftHandZeroFingersExtended
                          LeftHandOneFingersExtended
                          LeftHandTwoFingersExtended
                          LeftHandThreeFingersExtended
                          LeftHandFourFingersExtended
                          LeftHandFiveFingersExtended
           
          Description:    Informs consumer how many fingers fingers are extended and on which hand 
       */
        (function SideHandCountFingersExtended() {
            var extendedFingerCountLabel = fh.GetExtendedFingersCountLabel(hand);
            var extendedFingersIndicies = fh.GetExtendedFingersIndicies(hand);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: side + 'Hand' + extendedFingerCountLabel + 'FingersExtended',
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    extendedFingers: extendedFingersIndicies
                }
            });
        })(); // END {Side} Hand {Count} Fingers Extended

        /*
           Name:           {Side} Hand {Finger} Extended
   
           Outputs:        RightHandThumbFingerExtended
                           RightHandIndexFingerExtended
                           RightHandMiddleFingerExtended
                           RightHandRingFingerExtended
                           RightHandPinkyFingerExtended
                           LeftHandThumbFingerExtended
                           LeftHandIndexFingerExtended
                           LeftHandMiddleFingerExtended
                           LeftHandRingFingerExtended
                           LeftHandPinkyFingerExtended
           
           Description:    Informs consumer which fingers are extended and on which hand 
       */
        (function SideHandFingerDetected() {
            hand.fingers.forEach(function (finger) {
                var fingerName = fh.GetFingerLabel(finger.type);
                var gestureName = side + 'Hand' + fingerName + 'FingerExtended'

                if (finger.extended) {
                    var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

                    bus.publish({
                        channel: "Input.Processed.Efficio",
                        topic: gestureName,
                        source: source,
                        data: {
                            input: data,
                            hand: hand,
                            finger: finger.type,
                            gestureInformation: gestureInformation
                        }
                    });
                }
                else {
                    ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary, side);
                }
            });
        })(); // END {Side} Hand {Finger} Extended

        /*
            Name:           {Side} Hand Flexion Detected
    
            Outputs:        RightHandFlexion
                            LeftHandFlexion
        */
        (function SideHandFlexionDetected() {
            var gestureName = side + 'HandFlexion'
            var flexion = hh.Flexion(hand);
            if (flexion) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

                if (gestureInformation.FireCount > 10) {
                    bus.publish({
                        channel: "Input.Processed.Efficio",
                        topic: gestureName,
                        source: source,
                        data: {
                            input: data,
                            hand: hand,
                            flexion: flexion,
                            gestureInformation: gestureInformation
                        }
                    });
                }
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary, side);
            }
        })();// END {Side} Hand Flexion

        /*
            Name:           {Side} Hand Extension Detected
    
            Outputs:        RightHandExtension
                            LeftHandExtension
        */
        (function SideHandExtensionDetected() {
            var gestureName = side + 'HandExtension'
            var extension = hh.Extension(hand);
            if (extension) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

                if (gestureInformation.FireCount > 10) {
                    bus.publish({
                        channel: "Input.Processed.Efficio",
                        topic: gestureName,
                        source: source,
                        data: {
                            input: data,
                            hand: hand,
                            extension: extension,
                            gestureInformation: gestureInformation
                        }
                    });
                }
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary, side);
            }
        })();// END {Side} Hand Extension

        /*
            Name:           {Side} Hand Radial Deviation

            Outputs:        RightHandRadialDeviation
                            LeftHandRadialDeviation
        */
        (function SideHandRadialDeviation() {
            var gestureName = side + 'HandRadialDeviation'
            var deviation = hh.RadialDeviation(hand);
            if (deviation) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        deviation: deviation,
                        gestureInformation: gestureInformation
                    }
                });
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary, side);
            }
        })();// END {Side} Hand Radial Deviation

        /*
            Name:           {Side} Hand Ulnar Deviation

            Outputs:        RightHandUlnarDeviation
                            LeftHandUlnarDeviation
        */
        (function SideHandUlnarDeviation() {
            var gestureName = side + 'HandUlnarDeviation'
            var deviation = hh.UlnarDeviation(hand);
            if (deviation) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        deviation: deviation,
                        gestureInformation: gestureInformation
                    }
                });
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary, side);
            }
        })();// END {Side} Hand Ulnar Deviation

        /*
            Name:           {Side} Hand Supenation

            Outputs:        RightHandSupenation
                            LeftHandSupenation
        */
        (function SideHandSupenation() {
            var gestureName = side + 'HandSupenation'
            var supenation = hh.Supination(hand);
            if (supenation) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        supenation: supenation,
                        gestureInformation: gestureInformation
                    }
                });
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary, side);
            }
        })();// END {Side} Hand Supenation

        /*
            Name:           {Side} Hand Pronation

            Outputs:        RightHandPronation
                            LeftHandPronation
        */
        (function SideHanPronation() {
            var gestureName = side + 'HandPronation'
            var pronation = hh.Pronation(hand);
            if (pronation) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        pronation: pronation,
                        gestureInformation: gestureInformation
                    }
                });
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary, side);
            }
        })();// END {Side} Hand Pronation

        /*
           Name:           {Side} Hand Hyper Pronation

           Outputs:        RightHandHyperPronation
                           LeftHandHyperPronation
       */
        (function SideHandHyperPronation() {
            var gestureName = side + 'HandHyperPronation'
            var pronation = hh.HyperPronation(hand);
            if (pronation) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        pronation: pronation,
                        gestureInformation: gestureInformation
                    }
                });
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary, side);
            }
        })();// END {Side} Hand Hyper Pronation

        /*
           Name:           {Side} Hand Neutral

           Outputs:        RightHandNeutral
                           LeftHandNeutral
        */
        (function SideHandNeutral() {
            var gestureName = side + 'HandNeutral'
            var neutral = hh.Neutral(hand);
            if (neutral) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        neutral: neutral,
                        gestureInformation: gestureInformation
                    }
                });
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary, side);
            }
        })();// END {Side} Hand Neutral

        (function Pinch() {
            for (var i = 0; i < hand.fingers.length - 1; i++) {
                for (var j = i + 1; j < hand.fingers.length; j++) {
                    var gestureName = side + 'Hand' + fh.GetFingerLabel(i) + fh.GetFingerLabel(j) + 'Pinch';
                    var pinchDistance = fh.DistanceBetweenFingers(hand.fingers[i], hand.fingers[j]);

                    if (pinchDistance < 23) {
                        var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

                        bus.publish({
                            channel: "Input.Processed.Efficio",
                            topic: gestureName,
                            source: source,
                            data: {
                                input: data,
                                hand: hand,
                                pinchDistance: pinchDistance,
                                pinchFingersIndicies: [i, j],
                                gestureInformation: gestureInformation
                            }
                        });
                    }
                    else {
                        ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary, side);
                    }
                }
            }
        })();// END Pinch

        (function ThumbsUp() {
            var gestureName = side + 'ThumbsUp';
            if (hh.Neutral(hand) && fh.AreRequisiteFingersExtended([0], hand)) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary, side);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        gestureInformation: gestureInformation
                    }
                });
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary, side);
            }
        })();// END ThumbsUp
    }

    return {
        ProcessInput: ProcessInput
    }
});

﻿define('Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandGestureDetection',['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper', 'Helpers/Math'], function (bus, hh, fh, math) {
    function ProcessInput(data, hand, ActiveGesturesDictionary) {
        var source = 'Efficio Gesture Grimoire';
        var dictionary = 'OneHandGesture';
        var side;

        // Hand information
        (function HandInformation() {
            side = hh.GetSide(hand);
        })();

        (function SideHandSwipe() {
            var gestureName = side + 'HandSwipe';
            var isExecuting = false;
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary);

            if (hh.Extension(hand) && hh.Neutral(hand)) {
                if (typeof gestureInformation.ExtensionFramesCount === 'undefined') {
                    gestureInformation.ExtensionFramesCount = 0;
                    gestureInformation.PalmStartPosition = hand.palmPosition;
                    gestureInformation.MiddleFingerStartPosition = hand.middleFinger.tipPosition;
                    gestureInformation.StartFrame = hand.frame;

                    setTimeout(function () {
                        isExecuting = false;
                    }, 2000);
                } else {
                    gestureInformation.ExtensionFramesCount++;
                }

                isExecuting = true;
            } else {
                if (gestureInformation.ExtensionFramesCount > 10 && hh.Neutral(hand)) {
                    if (typeof gestureInformation.NeutralFramesCount === 'undefined') {
                        gestureInformation.NeutralFramesCount = 0;
                    } else {
                        gestureInformation.NeutralFramesCount++;
                    }

                    isExecuting = true;
                }
            }

            if (gestureInformation.ExtensionFramesCount > 10 && gestureInformation.NeutralFramesCount > 10 && hh.Flexion(hand) && !gestureInformation.Fired) {
                gestureInformation.EndTime = new Date();
                gestureInformation.PalmEndPosition = hand.palmPosition;
                gestureInformation.MiddleFingerEndPosition = hand.middleFinger.tipPosition;
                gestureInformation.StartFrame = hand.frame;
                gestureInformation.SwipeVelocity = math.Velocity(gestureInformation.MiddleFingerStartPosition, gestureInformation.MiddleFingerEndPosition, gestureInformation.GestureDuration());
                gestureInformation.Fired = true;

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        gestureInformation: gestureInformation
                    }
                });

                setTimeout(function () {
                    ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary);
                }, 250);
            }

            if (!isExecuting) {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary);
            }
        })();
    }

    return {
        ProcessInput: ProcessInput
    }
});

﻿define('Human Input Recognition and Processing/Hand Gestures/Two Hand Gestures/TwoHandPositionDetection',['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper', 'Helpers/Math'], function (bus, hh, fh, math) {
    function ProcessInput(data, hands, ActiveGesturesDictionary) {

        var source = 'Efficio Gesture Grimoire';
        var dictionary = 'TwoHandPosition';
        var FireCountMinimum = 15;

        (function BothHandsNeutral() {
            var gestureName = 'BothHandsNeutral'
            var neutrals = [hh.Neutral(hands[0]), hh.Neutral(hands[1])]

            if (neutrals[0] && neutrals[1]) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary);

                if (gestureInformation.FireCount > FireCountMinimum) {
                    gestureInformation.distance = math.DistanceBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);
                    gestureInformation.midpoint = math.MidpointBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);

                    bus.publish({
                        channel: "Input.Processed.Efficio",
                        topic: gestureName,
                        source: source,
                        data: {
                            input: data,
                            hand: hand,
                            neutrals: neutrals,
                            gestureInformation: gestureInformation
                        }
                    });
                }
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary);
            }
        })();// END Both Hands Neutral

        (function BothHandsPronation() {
            var gestureName = 'BothHandsPronation'
            var pronations = [hh.Pronation(hands[0]), hh.Pronation(hands[1])]

            if (pronations[0] && pronations[1]) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName, dictionary);

                if (gestureInformation.FireCount > FireCountMinimum) {
                    gestureInformation.distance = math.DistanceBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);
                    gestureInformation.midpoint = math.MidpointBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);

                    bus.publish({
                        channel: "Input.Processed.Efficio",
                        topic: gestureName,
                        source: source,
                        data: {
                            input: data,
                            hand: hand,
                            neutrals: pronations,
                        }
                    });
                }
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(gestureName, dictionary);
            }
        })();// END Both Hand Pronation
    }

    return {
        ProcessInput: ProcessInput
    }
});

﻿define('Human Input Recognition and Processing/Hand Gestures/HandGestureDetectionHandler',['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper'], function (bus, hh) {
    function ProcessInput(data, ActiveGesturesDictionary) {
        var source = 'Efficio Gesture Grimoire';
        var channel = 'Input.Processed.Efficio';

        // Check if there is any input and if the input contains hands
        if (data.input && data.input.hands) {

            var hands = data.input.hands;

            // Check if any hands are present
            (function NoHandsDetected() {
                var gestureName = 'NoHandsDetected'

                if (hands.length === 0) {
                    var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName)

                    bus.publish({
                        channel: channel,
                        topic: gestureName,
                        source: source,
                        data: {
                            message: 'No hands detected',
                            gestureInformation: gestureInformation
                        }
                    });

                    // Clear gesture dictionary for one and two hand gestures
                    ActiveGesturesDictionary.DeleteEntry(null, 'OneHandPosition');
                    ActiveGesturesDictionary.DeleteEntry(null, 'OneHandGesture');
                    ActiveGesturesDictionary.DeleteEntry(null, 'TwoHandPositione');
                    ActiveGesturesDictionary.DeleteEntry(null, 'TwoHandGesture');

                    // No need for processing any further
                    return;
                }
                else {
                    ActiveGesturesDictionary.DeleteEntry(gestureName);
                }
            })();

            // Detects each hand's presence independently
            if (hands.length > 0) {
                hands.forEach(function (hand) {
                    var gestureName = type + 'HandDetected';

                    // Send Message saying what hand was detected
                    var type = hand.type;
                    bus.publish({
                        channel: channel,
                        topic: gestureName,
                        source: source,
                        data: {
                            hand: hand
                        }
                    });

                    // Send data to the one hand position gesture detection libraries
                    require(['Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandPositionDetection'], function (ohgd) {
                        ohgd.ProcessInput(data, hand, ActiveGesturesDictionary);
                    });

                    // Send data to the one hand gesture detection library
                    require(['Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandGestureDetection'], function (ohgd) {
                        ohgd.ProcessInput(data, hand, ActiveGesturesDictionary);
                    });
                });
            }

                // Check if one hand is present
                (function OneHandDetected() {
                    if (hands.length === 1) {
                        var side = hh.GetSide(hands[0]);
                        var gestureName = 'OneHandDetected'
                        var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName)

                        var oppositeHand = side === 'Right' ? 'Left' : 'Right'

                        // Clear other hand gesture dictionary entries
                        ActiveGesturesDictionary.DeleteEntry(null, 'OneHandPosition', oppositeHand);
                        ActiveGesturesDictionary.DeleteEntry(null, 'OneHandGesture', oppositeHand);

                        // Clear two hand gesture dictionary entries
                        ActiveGesturesDictionary.DeleteEntry(null, 'TwoHandGesture');

                        // Send Message saying that a hand was detected
                        bus.publish({
                            channel: channel,
                            topic: gestureName,
                            source: source,
                            data: {
                                handCount: hands[0],
                                gestureInformation: gestureInformation
                            }
                        });
                    }
                    else {
                        ActiveGesturesDictionary.DeleteEntry(gestureName);
                    }
                })();

                // Check if any hand present
                if (hands.length  == 2) {
                    (function TwoHandsDetected(){
                        if (hands.length === 2) {
                            var gestureName = 'TwoHandDetected'
                            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(gestureName)

                            // Send Message saying that two hands were detected
                            bus.publish({
                                channel: channel,
                                topic: gestureName,
                                source: source,
                                data: {
                                    gestureInformation: gestureInformation
                                }
                            });

                            // Send data to the two hand gesture detection library
                            require(['Human Input Recognition and Processing/Hand Gestures/Two Hand Gestures/TwoHandPositionDetection'], function (thgd) {
                                thgd.ProcessInput(data, hands, ActiveGesturesDictionary);
                            });
                        }
                        else {

                        }
                    })();
                }
            }
        }


        return {
            ProcessInput: ProcessInput
        }
    })
;
﻿define('Human Input Recognition and Processing/EfficioGestureGrimoire',['postal'], function (bus) {
    var source = 'Efficio Gesture Grimoire';
    var ActiveGesturesDictionaryCopy = {};

    function DetectPredefinedGestures(data, envelope) {
        var trackingType = data.trackingType || '';

        switch (trackingType) {
            case 'Hands': {
                require(['Human Input Recognition and Processing/Hand Gestures/HandGestureDetectionHandler'], function (hgdh) {
                    hgdh.ProcessInput(data, ActiveGesturesDictionary)
                });
                break;
            }
            case 'Body': {
                // Body tracking library here
                break;
            }
            case 'Face': {
                // Face tracking library here
                break;
            }
            case 'Brain': {
                // Brain tracking library here
                break;
            }
        }
    }



    return {
        Initialize: function (agd) {
            ActiveGesturesDictionary = agd;
        },

        ProcessInput: function (data, envelope) {
            DetectPredefinedGestures(data, envelope);
        }
    }
});

﻿define('Human Input Recognition and Processing/HumanInputRecognitionAndProcessing',['postal', 'Human Input Recognition and Processing/ActiveGestureDictionary'], function (bus, agd) {
    return {
        Initialize: function () {
            require(['Human Input Recognition and Processing/CustomGestureLibrariesAccess'], function (customGestureLibraries) {
                customGestureLibraries.Initialize(agd);

                bus.subscribe({
                    channel: "Input.Raw",
                    topic: "*",
                    callback: function (data, envelope) {
                        customGestureLibraries.ProcessInput(data, envelope);
                    }
                });
            }), function (err) {
                bus.publish({
                    channel: 'UserNotification',
                    topic: 'Warn',
                    source: source,
                    data: {
                        message: 'No custom gesture library configured'
                    }
                });
            };

            require(['Human Input Recognition and Processing/EfficioGestureGrimoire'], function (efficioGestureLibrary) {
                efficioGestureLibrary.Initialize(agd);

                bus.subscribe({
                    channel: "Input.Raw",
                    topic: "*",
                    callback: function (data, envelope) {
                        efficioGestureLibrary.ProcessInput(data, envelope);
                    }
                });
            });

            //require(['Human Input Recognition and Processing/EfficioAudioGrimoire'], function (efficioAudioGrimoire) {
            //    efficioAudioGrimoire.Initialize();

            //    bus.subscribe({
            //        channel: "Input.Audio.Raw",
            //        topic: "*",
            //        callback: function (data, envelope) {
            //            efficioAudioGrimoire.ProcessInput(data, envelope);
            //        }
            //    });
            //});
        }
    }
});

﻿define('InternalScene',['THREE'], function () {
    var scene = new THREE.Scene();

    return {
        Initialize: function () {
        
        }, 
    
        Scene: scene
    }
});

﻿define('Asset Management and Inventory/AssetManager',['postal', 'InternalScene'], function (bus, internalScene) {
    var source = "Efficio Asset Manager"

    function CreateAsset(asset) {
        bus.publish({
            channel: "UserNotification",
            topic: "AssetCreated",
            source: source,
            data: {
                message: "Asset created with data: " + asset
            }
        });

        internalScene.Scene.add(asset);
    };

    function CreateAssets(assets) {

    };

    function RetrieveAsset(assetID) {

    };

    function RetrieveAssets(assetIDs) {

    };

    function RetrieveAllAssets() {

    };

    function RetrieveAllAssetIDs() {

    };

    function UpdateAsset(asset) {
        var oldAsset = internalScene.Scene.getObjectById(asset.id);

        internalScene.Scene.remove(oldAsset);
        internalScene.Scene.add(asset);

        asset = internalScene.Scene.getObjectById(asset.id);

        bus.publish({
            channel: "UserNotification",
            topic: "AssetUpdated",
            source: source,
            data: {
                message: source + " - Asset Updated: \nID: " + asset.id + "\nPosition: (" + asset.position.x + " , " + asset.position.y + ", " + asset.position.z + ")" + "\nScale: (" + asset.scale.x + " , " + asset.scale.y + ", " + asset.scale.z + ")"
            }
        });
    };

    function UpdateAssets(assets) {

    };

    function DeleteAsset(assetID) {

    };

    function DeleteAssets(assetIDs) {

    };

    function DeleteAllAssets() {

    };

    function GetValueForProperty(property, data) {
        switch (property) {
            case "ClosestAsset":
                {
                    return GetClosestAsset(data);
                }
        }
    }

    function GetClosestAsset(data) {
        if (data.location === null) {
            bus.publish({
                channel: "Exception.Efficio",
                topic: "GetClosestAsset",
                source: source,
                data: {
                    message: "GetClosestAsset function requires location argument"
                }
            });
        }
        return "Asset closest to point (" + data.Location.x + ", " + data.Location.y + ", " + data.Location.z + ")"
    }

    return {
        Initialize: function () {
            if (typeof window != 'undefined') {
                //var http = new XMLHttpRequest();
                //http.open('HEAD', '/debug.html', false);
                //http.send();

                //if (http.status != 404) {
                //    var params = [
                //        'height=' + screen.height,
                //        'width=' + screen.width,
                //        'fullscreen=yes' // only works in IE, but here for completeness
                //    ].join(',');

                //    window.open('/debug.html', 'AMI Debugger', params);
                //}
            }
        },

        CreateAsset: CreateAsset,

        CreateAssets: CreateAssets,

        RetrieveAsset: RetrieveAsset,

        RetrieveAssets: RetrieveAssets,

        RetrieveAllAssets: RetrieveAllAssets,

        RetrieveAllAssetIDs: RetrieveAllAssetIDs,

        UpdateAsset: UpdateAsset,

        UpdateAssets: UpdateAssets,

        DeleteAsset: DeleteAsset,

        DeleteAssets: DeleteAssets,

        DeleteAllAssets: DeleteAllAssets,

        GetValueForProperty: GetValueForProperty,

    }
});

﻿define('Constraints Engine/ConstraintsEngine',['postal', 'Asset Management and Inventory/AssetManager'], function (bus, ami) {
    var source = "Efficio Constraints Engine";
    var violated = false;

    var subscriptions = new Array();

    function RegisterSubscriber(subscription) {
        subscriptions.push(subscription);
    }

    function CheckConstraints(data) {
        //if (violated) {
        //    console.log('Constraints violated, changes not reflected internally.')
        //}
        //else {
        //    console.log('Constraints not violated, changes reflected internally.')
        //}

        return true;
    }

    return{
        Initialize: function () {

        }
    };
});

﻿define('Command Issuance and Control/CommandIssuanceAndControl',['postal', 'Asset Management and Inventory/AssetManager'], function (bus, ami) {
    return {
        Initialize: function () {
            var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
            var ARGUMENT_NAMES = /([^\s,]+)/g;

            function getParamNames(func) {
                var fnStr = func.toString().replace(STRIP_COMMENTS, '');
                var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
                if (result === null)
                    result = [];
                return result;
            }

            ActionToFunctionMapping.ActionMappings.forEach(function (mapping) 
            {
                bus.subscribe({
                    channel: mapping.Source,
                    topic: mapping.Topic,
                    callback: function (data, envelope) {
                        var func = mapping.Action;

                        if (typeof func != 'function') {
                            func = ActionToFunctionMapping.Bridge[mapping.Action];
                        }

                        // Get method parameters
                        var functionParameters = getParamNames(func);

                        var argMapping = {};

                        // Create args for function call
                        var args = [];

                        if (mapping.Arguments) {
                            functionParameters.forEach(function (param) {
                                var params = mapping.Arguments.filter(function (argument) {
                                    return argument.MapTo === param;
                                });

                                if (params.length > 0) {
                                    var value;

                                    if (params[0].Source && params[0].Source === 'AssetManager') {
                                        value = ami.GetValueForProperty(params[0].Name, data);
                                    }
                                    else {
                                        value = data[params[0].Name];
                                    }

                                    args.push(value);
                                }
                                else {
                                    args.push(null);
                                }
                            });
                        }
                        else {
                            args = [data];
                        }
                       
                        func.apply(null, args);
                    }
                })
            });
        }
    };
});

﻿define('Logging/SystemNotificationListener',['postal'], function (bus) {
    return {
        Initialize: function () {
            bus.subscribe({
                channel: "SystemNotification",
                topic: "*",
                callback: function (data, envelope) {
                    console.log(envelope.topic + ": " + data.message);
                }
            });
        }
    }
});

﻿define('Input/LeapMotion/LeapMotion',['postal', 'leapjs'], function (bus, Leap) {
    var source = 'Leap Motion';
    var trackingType = 'Hands';
    var controller;

    function configure(LeapConfiguration)
    {
        LeapConfiguration = {
            Host: LeapConfiguration.Host || 'localhost',
            Port: LeapConfiguration.Port || 6437,
            EnableGestures: LeapConfiguration.EnableGestures || false,
            FrameEventName: LeapConfiguration.FrameEventName || 'animationFrame',
            UseAllPlugins: LeapConfiguration.UseAllPlugins || false
        }

        return LeapConfiguration;
    }

    return {
        Initialize: function (LeapConfiguration) {

            // Load Configuration
            LeapConfiguration = configure(LeapConfiguration);
            
            // Create Controller
            controller = new Leap.Controller({
                host: LeapConfiguration.Host,
                port: LeapConfiguration.Port,
                enableGestures: LeapConfiguration.EnableGestures,
                frameEventName: LeapConfiguration.FrameEventName,
                useAllPlugins: LeapConfiguration.UseAllPlugins
            });

            // Register Leap's native gesture recognition
            controller.on("gesture", function (gesture) {
                if (gesture.state == "stop") {
                    bus.publish({
                        channel: 'Input.Raw',
                        topic: 'Gesture',
                        source: source,
                        data: {
                            name: gesture.type,
                            gesture: gesture
                        }
                    });
                }
            });

            // Sends message when controller is connected
            controller.on("connect", function () {
                bus.publish({
                    channel: 'Devices',
                    topic: 'Connected',
                    source: source,
                    data: {
                        name: source,
                        device: Leap,
                        controller: controller,
                        test: 'test'
                    }
                });
            });

            controller.connect();
        },

        Start: function () {

            // Listens for input from device
            controller.loop(function (frame) {
                if (frame.valid) {
                    bus.publish({
                        channel: 'Input.Raw',
                        topic: 'Leap',
                        source: source,
                        data: {
                            trackingType: trackingType,
                            input: frame
                        }
                    });
                }
            });
        }
    }
});

define('Input/Microsoft Kinect/Kinect', ['postal'], function (bus) {
    var source = 'Kinect';
    var trackingType = 'Seated';
    var controller;
    var device = "Kinect1.8";

    function configure(KinectConfiguration) {
        KinectConfiguration = {
            Server: KinectConfiguration.Host || "ws://localhost:8181",
            LogActions: KinectConfiguration.LogActions || false
        }

        return KinectConfiguration;
    }

    return {
        Initialize: function (KinectConfiguration) {

            // Create Controller
            controller = new WebSocket(KinectConfiguration.Server);

            // Sends message when controller is connected
            controller.onopen = function () {

                if (KinectConfiguration.LogActions == true) {
                    console.log("Connection successful.");
                }

                bus.publish
                ({
                    channel: 'Devices',
                    topic: 'Connected',
                    source: source,
                    data: {
                        name: source,
                        device: "Kinect",
                        controller: controller,
                        test: 'test'
                    }
                });
            };

            // Connection closed.
            controller.onclose = function () {
                if (KinectConfiguration.LogActions == true) {
                    console.log("Connection closed.");
                }
            }
        },

        Start: function () {

            // Listens for input from device
            controller.onmessage = function (frame) {

                if (KinectConfiguration.LogActions == true) {
                    console.log("received data from socket");
                }

                // SKELETON DATA
                var jsonObject = JSON.parse(frame.data);

                if (KinectConfiguration.LogActions == true) {
                    console.log(frame);
                }

                bus.publish
                ({
                    channel: 'Input.Raw',
                    topic: device,
                    source: source,
                    data:
                    {
                        trackingType: trackingType,
                        input: frame
                    }
                });
            };
        }
    }
});

﻿define('Input/Microphone/Microphone',['postal', 'annyang'], function (bus, annyang) {

    var source = 'Microphone';
    var recognition;
    var autoRestart = true;
    var lastStartedAt = 0;

    return {
        Intitialize: function () {

            if (typeof annyang != 'undefined') {
                
                if (typeof ActionToFunctionMapping.AudioCommands != 'undefined') {
                    // Add our commands to annyang
                    annyang.addCommands(ActionToFunctionMapping.AudioCommands);
                }
            }
        },
        Start: function () {
            if (annyang) {
                annyang.start();

                bus.publish({
                    channel: 'Devices',
                    topic: 'Connected',
                    source: source,
                    data: {
                        name: source,
                        test: 'test'
                    }
                });
            }
        }
    }
});

﻿define('Efficio',[
    'Message Bus/MessageBus',
    'Human Input Recognition and Processing/HumanInputRecognitionAndProcessing',
    'Asset Management and Inventory/AssetManager',
    'Constraints Engine/ConstraintsEngine',
    'Command Issuance and Control/CommandIssuanceAndControl',
    'InternalScene',
    'Logging/SystemNotificationListener',
    //'Sequence Execution and Action Scheduling/CollisionDetectionAndGravitySimulation',
],

function (bus, hirp, ami, constraintsEngine, comm, internalScene, sysNotificationListener) {
    var leapmotion;
    var microphone;

    function configure(EfficioConfiguration) {
        EfficioConfiguration.devices = EfficioConfiguration.devices || { microphone: false, kinect: false, leapmotion: false };
        EfficioConfiguration.debug = EfficioConfiguration.debug || false;
    }

    return {
        Initialize: function (EfficioConfiguration) {
            configure(EfficioConfiguration);
            bus.Initialize();
            hirp.Initialize();
            ami.Initialize();
            constraintsEngine.Initialize();
            comm.Initialize();
            internalScene.Initialize();
            sysNotificationListener.Initialize();

            if (EfficioConfiguration.devices.leapmotion) {
                require(['Input/LeapMotion/LeapMotion'], function (leap) {
                    leapmotion = leap;
                    leapmotion.Initialize(EfficioConfiguration.devices.leapmotion);
                    leapmotion.Start();
                });
            }

            if (EfficioConfiguration.devices.microphone) {
                require(['Input/Microphone/Microphone'], function (mic) {
                    microphone = mic;
                    microphone.Intitialize();
                    microphone.Start();
                });
            }
        },
        Start: function () {

        }
    }
});

﻿if (typeof THREE === 'object') {
    define('THREE', function () { return THREE; });
}

if (typeof Leap === 'function') {
    define('leapjs', function () { return Leap; });
}

require(["Efficio"], function (Efficio) {
    Efficio.Initialize(EfficioConfiguration);
    Efficio.Start();
});

define("main", function(){});

