define('Human Input Recognition and Processing/ActiveGestureDictionary',[],function () {
    var ActiveGesturesDictionary = {}

    //function RetrieveEntry(trackingType, gestureName, ...dictionary) { '...' is not supported yet
    function RetrieveEntry(trackingType, gestureName) {
        trackingType = trackingType || 'NoTrackingType';

        // Get all subdictionaries; workaround for '...' not being supported
        var argumentsLength = arguments.length;
        if (argumentsLength > 2) {
            var dictionaries = [];

            for (var i = 2; i < argumentsLength; i++) {
                dictionaries.push(arguments[i]);
            }
        }

        if (!gestureName) {
            console.error('gestureName argument required.');
        }

        if (!ActiveGesturesDictionary[trackingType]) {
            ActiveGesturesDictionary[trackingType] = {};
        }

        var path = ActiveGesturesDictionary[trackingType];

        if (dictionaries) {
            var dictLength = dictionaries.length;

            for (var i = 0; i < dictLength; i++) {
                if (!path[dictionaries[i]]) {
                    path[dictionaries[i]] = {};
                }

                path = path[dictionaries[i]];
            }
        }

        return path[gestureName];
    }

    //function AddEntry(entry, trackingType, gestureName, ...dictionary) { '...' is not supported yet
    function AddEntry(entry, trackingType, gestureName) {
        trackingType = trackingType || 'NoTrackingType';

        if (!gestureName) {
            console.error('gestureName argument required.');
        }

        // Get all subdictionaries; workaround for '...' not being supported
        var argumentsLength = arguments.length;
        if (argumentsLength > 3) {
            var dictionaries = [];

            for (var i = 3; i < argumentsLength; i++) {
                dictionaries.push(arguments[i]);
            }
        }

        if (!ActiveGesturesDictionary[trackingType]) {
            ActiveGesturesDictionary[trackingType] = {};
        }

        var path = ActiveGesturesDictionary[trackingType];

        if (dictionaries) {
            var dictLength = dictionaries.length;

            for (var i = 0; i < dictLength; i++) {
                if (!path[dictionaries[i]]) {
                    path[dictionaries[i]] = {};
                }

                path = path[dictionaries[i]];
            }
        }

        path[gestureName] = entry;
    }

    //function CreateOrUpdateEntry(trackingType, gestureName, ...dictionary) { '...' is not supported yet
    function CreateOrUpdateEntry(trackingType, gestureName) {

        // Get all subdictionaries; workaround for '...' not being supported
        var dictionaries = [];
        var argumentsLength = arguments.length;
        if (argumentsLength > 2) {
            for (var i = 2; i < argumentsLength; i++) {
                dictionaries.push(arguments[i]);
            }
        }

        var retrieveVars = [trackingType, gestureName].concat(dictionaries);

        var entry = RetrieveEntry.apply(null, retrieveVars);

        if (!entry) {
            entry = {
                // Time properties
                StartTime: new Date(),
                EndTime: null,
                GestureDuration: function () {
                    var endTime = this.EndTime || new Date();

                    return Math.abs(this.StartTime - endTime)
                },

                // Fire count properties
                FireCount: 0,
                FirstFire: function () { return this.FireCount === 0 }
            }

            var addVars = [entry].concat(retrieveVars);
            AddEntry.apply(null, addVars);
        }
        else {
            entry.FireCount++;
        }

        return entry;
    }

    //function DeleteEntry(trackingType, gestureName, ...dictionary) { '...' is not supported yet
    function DeleteEntry(trackingType, gestureName) {
        trackingType = trackingType || 'NoTrackingType';
        var toDelete;

        if (!ActiveGesturesDictionary[trackingType]) {
            return;
        }

        // Get all subdictionaries; workaround for '...' not being supported
        var argumentsLength = arguments.length;
        if (argumentsLength > 2) {
            var dictionaries = [];

            for (var i = 2; i < argumentsLength; i++) {
                dictionaries.push(arguments[i]);
            }
        }

        var toDelete = ActiveGesturesDictionary;

        if (dictionaries) {
            var lastEntry;
            var dictLength = dictionaries.length;

            for (var i = 0; i < dictLength; i++) {
                if (!toDelete[dictionaries[i]]) {
                    return;
                }

                if (!i === dictLength-1) {
                    toDelete = toDelete[dictionaries[i]];
                }
                else {
                    lastEntry = dictionaries[i];
                }
            }
        }
        else {
            lastEntry = trackingType;
        }

        if (gestureName && toDelete) {
            delete toDelete[lastEntry][gestureName];
        }
        else {
            delete toDelete[lastEntry];
        }
    }

    //function DeleteAllBut(trackingType, gestureName, ...dictionary) { '...' is not supported yet
    function DeleteAllBut(trackingType, gestureName) {
        trackingType = trackingType || 'NoTrackingType';

        if (!ActiveGesturesDictionary[trackingType]) {
            return;
        }

        if (!gestureName) {
            throw Exception('gestureName argument required.');
        }

        // Get all subdictionaries; workaround for '...' not being supported
        var argumentsLength = arguments.length;
        if (argumentsLength > 2) {
            var dictionaries = [];

            for (var i = 2; i < argumentsLength; i++) {
                dictionaries.push(arguments[i]);
            }
        }

        var toDelete = ActiveGesturesDictionary[trackingType];

        if (dictionaries) {
            var dictLength = dictionaries.length;

            for (var i = 0; i < dictLength; i++) {
                if (!toDelete[dictionaries[i]]) {
                    return;
                }

                toDelete = toDelete[dictionaries[i]];
            }
        }

        for (var prop in toDelete) {
            if (prop != gestureName) {
                delete toDelete[prop];
            }
        }
    }

    return {
        ActiveGesturesDictionary: ActiveGesturesDictionary,
        CreateOrUpdateEntry: CreateOrUpdateEntry,
        RetrieveEntry: RetrieveEntry,
        DeleteEntry: DeleteEntry,
        DeleteAllBut: DeleteAllBut
    }
});

﻿'use strict'

define('Helpers/Math',[],function () {

    function GetAngleBetweenVectors(vector1, vector2)
    {
        var a = {
            x: vector1[0],
            y: vector1[1],
            z: vector1[2]
        }

        var b = {
            x: vector2[0],
            y: vector2[1],
            z: vector2[2]
        }

        var axb = a.x * b.x + a.y * b.y + a.z * b.z;
        var vector1Length = Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
        var vector2Length = Math.sqrt(b.x * b.x + b.y * b.y + b.z * b.z);

        return Math.acos(axb / (vector1Length * vector2Length)) * (180 / Math.PI)
    }

    function DistanceBetweenTwoPoints(point1, point2) {
        var a = {
            x: point1[0],
            y: point1[1],
            z: point1[2] || 0
        }

        var b = {
            x: point2[0],
            y: point2[1],
            z: point2[2] || 0
        }

        return Math.sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y) + (b.z - a.z) * (b.z - a.z))
    }

    function MidpointBetweenTwoPoints(point1, point2) {
        var a = {
            x: point1[0],
            y: point1[1],
            z: point1[2] || 0
        }

        var b = {
            x: point2[0],
            y: point2[1],
            z: point2[2] || 0
        }

        return [(b.x - a.x) / 2, (b.y - a.y) / 2, (b.z - a.z) / 2];
    }

    function Velocity(point1, point2, time) {
        return (DistanceBetweenTwoPoints(point1, point2) / (time / 1000));
    }

    return {
        GetAngleBetweenVectors: GetAngleBetweenVectors,
        DistanceBetweenTwoPoints: DistanceBetweenTwoPoints,
        MidpointBetweenTwoPoints: MidpointBetweenTwoPoints,
        Velocity: Velocity
    }
})
;
﻿define('Human Input Recognition and Processing/Input Extensions/LeapMotion/LeapMotionHandExtensions',['leapjs', 'Helpers/Math'], function (Leap, math) {

    function IsFlexed(hand) {
        var hand = hand || this;
        var middleFingerTip = hand.fingers[2].tipPosition;
        var palmPosition = hand.palmPosition;
        var isFlexed = FlexionAngle(hand) >= hand.FlexedAngle;

        var measure = hand.roll() * (180 / Math.PI);

        if (hand.type === 'right') {
            measure = -measure;
        }

        if (measure > 90) {
            return isFlexed && middleFingerTip[1] > palmPosition[1];
        }
        else {
            return isFlexed && middleFingerTip[1] < palmPosition[1];
        }        
    }

    function FlexionAngle(hand) {
        var hand = hand || this;
        var angleCorrector = 1;
        var measure = hand.roll() * (180 / Math.PI);

        if (hand.type === 'right') {
            measure = -measure;

            if (measure >= -11) {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
        }
        else {
            if (measure >= -11) {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
        }

        var angle = math.GetAngleBetweenVectors(hand.direction, hand.arm.direction());

        return angle * angleCorrector;
    }

    function IsExtended(hand) {
        var hand = hand || this;
        var middleFingerTip = hand.fingers[2].tipPosition;
        var palmPosition = hand.palmPosition;
        var isFlexed = FlexionAngle(hand) >= hand.ExtendedAngle;

        var measure = hand.roll() * (180 / Math.PI);

        if (hand.type === 'right') {
            measure = -measure;
        }

        if (measure < 90) {
            return isFlexed && middleFingerTip[1] > palmPosition[1];
        }
        else {
            return isFlexed && middleFingerTip[1] < palmPosition[1];
        }
    }

    function ExtensionAngle(hand) {
        var hand = hand || this;
        var angleCorrector = 1;
        var measure = hand.roll() * (180 / Math.PI);

        if (hand.type === 'right') {
            measure = -measure;

            if (measure >= -11) {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
        }
        else {
            if (measure >= -11) {
                angleCorrector = hand.direction[0] < 0 ? 1 : -1;
            }
            else {
                angleCorrector = hand.direction[0] > 0 ? 1 : -1;
            }
        }

        var angle = math.GetAngleBetweenVectors(hand.direction, hand.arm.direction());

        return angle * angleCorrector;
    }

    function IsSupine(hand) {
        var hand = hand || this;

        return SupinationAngle(hand) > hand.SupineAngle;
    }

    function SupinationAngle(hand) {
        var hand = hand || this;
        var measure = hand.roll() * (180 / Math.PI);
        return hand.type === 'right' ? -measure : measure;
    }

    function IsNeutral(hand) {
        var hand = hand || this;

        return !IsSupine(hand) && !IsProne(hand) && !IsHyperRotated(hand);
    }

    function IsProne(hand) {
        var hand = hand || this;

        return PronationAngle(hand) > -hand.ProneAngleTolerance && PronationAngle(hand) < hand.ProneAngleTolerance;
    }

    function PronationAngle(hand) {
        var hand = hand || this;
        var measure = hand.roll() * (180 / Math.PI);
        return hand.type == 'right' ? -measure : measure;
    }

    function IsHyperRotated(hand) {
        var hand = hand || this;
        var measure = HyperRotationAngle(hand);

        return measure < -hand.ProneAngleTolerance;
    }

    function HyperRotationAngle(hand) {
        var hand = hand || this;
        var measure = hand.roll() * (180 / Math.PI);
        return hand.type == 'right' ? -measure : measure;
    }

    function IsUlnarDeviated(hand) {
        var hand = hand || this;
        return DeviatedMeasurment(hand) > hand.UlnarDeviatedMeasure;
    }

    function IsRadialDeviated(hand) {
        var hand = hand || this;
        return DeviatedMeasurment(hand) < hand.RadialDeviatedMeasure;
    }

    function DeviatedMeasurment(hand) {
        var hand = hand || this;
        return hand.type === 'right' ? hand.direction[0] - hand.arm.direction()[0] : -1 * hand.direction[0] - (-1) * hand.arm.direction()[0];
    }

    function GetType(hand) {
        var hand = hand || this;
        return hand.type === 'right' ? 'Right' : 'Left';
    }

    function ExtendClasses() {
        var extensions = {
            // Flex Helpers
            IsFlexed: IsFlexed,
            FlexedAngle: 30,
            FlexionAngle: FlexionAngle,

            // Extension Helpers
            IsExtended: IsExtended,
            ExtendedAngle: 25,
            ExtensionAngle: ExtensionAngle,

            // Supination
            IsSupine: IsSupine,
            SupineAngle: 145,
            SupinationAngle: SupinationAngle,

            // Neutral
            IsNeutral: IsNeutral,

            // Pronation
            IsProne: IsProne,
            ProneAngleTolerance: 15,
            PronationAngle: PronationAngle,

            // Hyper Rotation
            IsHyperRotated: IsHyperRotated,
            HyperRotationAngle: HyperRotationAngle,

            // Ulnar Deviation
            IsUlnarDeviated: IsUlnarDeviated,
            UlnarDeviatedMeasure: .5,
            DeviatedMeasurment: DeviatedMeasurment,

            // Radial Deviation
            IsRadialDeviated: IsRadialDeviated,
            RadialDeviatedMeasure: -.2,

            // Others
            GetType: GetType
        }

        for (var property in extensions) {
            Leap.Hand.prototype[property] = extensions[property];
        }

        return extensions;
    }

    return {
        ExtendClasses: ExtendClasses
    }
})
;
﻿define('Human Input Recognition and Processing/CustomGestureLibrariesAccess',['postal'], function (bus) {
    var source = 'Custom Gesture Libraries';
    var ActiveGesturesDictionaryCopy = {};

    function LoadCustomGestures() {
        // Custom Gestures created by the user will be loaded here
    }

    function DetectCustomGestures(data, envelope) {
        var libraryName = 'custom library 1';
        var gestureName = 'my custom gesture';
        var gestureData = 'my custom gesture data';

        // If custom gesture is detected
        if (data.input === 'BVH representation of a custom gesture') {

            bus.publish({
                channel: "Input.Processed.Custom." + libraryName,
                topic: gestureName,
                source: source,
                data: gestureData
            });
        }
    }

    return {
        Initialize: function (ActiveGesturesDictionary) {
            ActiveGesturesDictionaryCopy = ActiveGesturesDictionary;
        },
        ProcessInput: function (data, envelope) {

            // Where input is processed and Custom Gestures are published on the channel
            DetectCustomGestures(data, envelope);
        }
    }
})
;
﻿define('Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper',[],function () {
    var fingerCountLabelsMap = ["Zero", "One", "Two", "Three", "Four", "Five"];
    var fingerNameLabelMap = ["Thumb", "Index", "Middle", "Ring", "Pinky"];

    function GetExtendedFingers(hand){
        return hand.fingers.filter(function (finger) {
            return finger.extended;
        });
    }

    function GetExtendedFingersIndicies(hand) {
        return GetExtendedFingers(hand).map(function (finger) {
            return finger.type
        });
    }

    function GetFingerLabel(fingerIndex) {
        return fingerNameLabelMap[fingerIndex];
    }

    function GetExtendedFingersCount(hand) {
        return GetExtendedFingers(hand).length;
    }

    function GetExtendedFingersCountLabel(hand) {
        return fingerCountLabelsMap[GetExtendedFingersCount(hand)];
    }

    function AreRequisiteFingersExtended(neededFingersArray, hand) {
        var extendedFingers = GetExtendedFingersIndicies(hand);

        return extendedFingers.filter(function (finger) {
            return neededFingersArray.indexOf(finger) != -1
        }).length === neededFingersArray.length && extendedFingers.length === neededFingersArray.length;
    }
    
    function DistanceBetweenFingers(finger1, finger2) {
        var finger1Tip = finger1.tipPosition;
        var finger2Tip = finger2.tipPosition;
        var x2 = finger1Tip[0];
        var y2 = finger1Tip[1];
        var z2 = finger1Tip[2];
        var x1 = finger2Tip[0];
        var y1 = finger2Tip[1];
        var z1 = finger2Tip[2];

        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1))
    }

    return {
        GetExtendedFingers: GetExtendedFingers,
        GetExtendedFingersIndicies: GetExtendedFingersIndicies,
        GetFingerLabel: GetFingerLabel,
        GetExtendedFingersCount: GetExtendedFingersCount,
        GetExtendedFingersCountLabel: GetExtendedFingersCountLabel,
        AreRequisiteFingersExtended: AreRequisiteFingersExtended,
        DistanceBetweenFingers: DistanceBetweenFingers
    }
})
;
﻿define('Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandPositionDetection',['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper'], function (bus, fh) {
    var source = 'Efficio Gesture Grimoire';
    var name = 'One Hand Gesture Detector';
    var dictionary = 'OneHandPosition';
    var trackingType = 'Hands';
    var side;
    var oneHandPositionDetector;
    var ActiveGesturesDictionary;

    /*
          Name:           {Side} Hand Detected
   
          Outputs:        RightHandDetected
                          LeftHandDetected
           
          Description:    Informs consumer how many fingers fingers are extended and on which hand 
       */
    function SideHandDetected(hand, data) {
        var gestureName = side + 'HandDetected';

        //TODO: Clear all entries in agd
        var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

        bus.publish({
            channel: "Input.Processed.Efficio",
            topic: gestureName,
            source: source,
            data: {
                input: data,
                hand: hand,
                gestureInformation: gestureInformation
            }
        });
    }

    /*
          Name:           {Side} Hand {Count} Fingers Extended
   
          Outputs:        RightHandZeroFingersExtended
                          RightHandOneFingersExtended
                          RightHandTwoFingersExtended
                          RightHandThreeFingersExtended
                          RightHandFourFingersExtended
                          RightHandFiveFingersExtended
                          LeftHandZeroFingersExtended
                          LeftHandOneFingersExtended
                          LeftHandTwoFingersExtended
                          LeftHandThreeFingersExtended
                          LeftHandFourFingersExtended
                          LeftHandFiveFingersExtended
           
          Description:    Informs consumer how many fingers fingers are extended and on which hand 
       */
    function SideHandCountFingersExtended(hand, data) {
        var extendedFingerCountLabel = fh.GetExtendedFingersCountLabel(hand);
        var extendedFingersIndicies = fh.GetExtendedFingersIndicies(hand);

        //TODO: Clear all entries in agd and add new entry

        bus.publish({
            channel: "Input.Processed.Efficio",
            topic: side + 'Hand' + extendedFingerCountLabel + 'FingersExtended',
            source: source,
            data: {
                input: data,
                hand: hand,
                extendedFingers: extendedFingersIndicies
            }
        });
    }; // END {Side} Hand {Count} Fingers Extended

    /*
   Name:           {Side} Hand {Finger} Extended

   Outputs:        RightHandThumbFingerExtended
                   RightHandIndexFingerExtended
                   RightHandMiddleFingerExtended
                   RightHandRingFingerExtended
                   RightHandPinkyFingerExtended
                   LeftHandThumbFingerExtended
                   LeftHandIndexFingerExtended
                   LeftHandMiddleFingerExtended
                   LeftHandRingFingerExtended
                   LeftHandPinkyFingerExtended
   
   Description:    Informs consumer which fingers are extended and on which hand 
*/
    function SideHandFingerDetected(hand, data) {
        hand.fingers.forEach(function (finger) {
            var fingerName = fh.GetFingerLabel(finger.type);
            var gestureName = side + 'Hand' + fingerName + 'FingerExtended'

            if (finger.extended) {
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        finger: finger.type,
                        gestureInformation: gestureInformation
                    }
                });
            }
            else {
                ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
            }
        });
    }; // END {Side} Hand {Finger} 

    /*
    Name:           {Side} Hand Flexion Detected

    Outputs:        RightHandFlexion
                    LeftHandFlexion
*/
    function SideHandFlexionDetected(hand, data) {
        var gestureName = side + 'HandFlexed'
        if (hand.IsFlexed()) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            if (gestureInformation.FireCount > 25) {
                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        gestureInformation: gestureInformation
                    }
                });
            }
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Flexion

    /*
    Name:           {Side} Hand Extension Detected

    Outputs:        RightHandExtension
                    LeftHandExtension
*/
    function SideHandExtensionDetected(hand, data) {
        var gestureName = side + 'HandExtended'
        if (hand.IsExtended()) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            if (gestureInformation.FireCount > 25) {
                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        gestureInformation: gestureInformation
                    }
                });
            }
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Extension

    /*
    Name:           {Side} Hand Radial Deviation

    Outputs:        RightHandRadialDeviation
                    LeftHandRadialDeviation
*/
    function SideHandRadialDeviation(hand, data) {
        var gestureName = side + 'HandRadialDeviation'
        if (hand.IsRadialDeviated()) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Radial Deviation

    /*
           Name:           {Side} Hand Ulnar Deviation

           Outputs:        RightHandUlnarDeviation
                           LeftHandUlnarDeviation
       */
    function SideHandUlnarDeviation(hand, data) {
        var gestureName = side + 'HandUlnarDeviation';
        if (hand.IsUlnarDeviated()) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Ulnar Deviation

    /*
            Name:           {Side} Hand Supenation

            Outputs:        RightHandSupenation
                            LeftHandSupenation
        */
    function SideHandSupenation(hand, data) {
        var gestureName = side + 'HandSupine'
        if (hand.IsSupine()) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Supenation

    /*
            Name:           {Side} Hand Pronation

            Outputs:        RightHandPronation
                            LeftHandPronation
        */
    function SideHandPronation(hand, data) {
        var gestureName = side + 'HandProne'
        if (hand.IsProne()) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Pronation

    /*
           Name:           {Side} Hand Hyper Pronation

           Outputs:        RightHandHyperRotated
                           LeftHandHyperRotated
       */
    function SideHandHyperRotated(hand, data) {
        var gestureName = side + 'HandHyperRotated'
        if (hand.IsHyperRotated()) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Hyper Pronation

    /*
           Name:           {Side} Hand Neutral

           Outputs:        RightHandNeutral
                           LeftHandNeutral
        */
    function SideHandNeutral(hand, data) {
        var gestureName = side + 'HandNeutral';
        if (hand.IsNeutral()) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END {Side} Hand Neutral

    function SideHandFlexAndRotation(hand, data) {
        var rotation = hand.IsSupine() ? 'Supine' : hand.IsNeutral() ? 'Neutral' : hand.IsProne() ? 'Prone' : 'Hyperrotated';
        var flex = hand.IsFlexed() ? 'Flexed' : hand.IsExtended() ? 'Extended' : 'Neutral';
        var gestureName = side + 'Hand' + flex + 'And' + rotation;

        var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side, "Combined");
        ActiveGesturesDictionary.DeleteAllBut(trackingType, gestureName, dictionary, side, "Combined")

        bus.publish({
            channel: "Input.Processed.Efficio",
            topic: gestureName,
            source: source,
            data: {
                input: data,
                hand: hand,
                gestureInformation: gestureInformation
            }
        });
    }

    function Pinch(hand, data) {
        var fingersCount = hand.fingers.length;
        for (var i = 0; i < fingersCount - 1; i++) {
            for (var j = i + 1; j < fingersCount; j++) {
                var gestureName = side + 'Hand' + fh.GetFingerLabel(i) + fh.GetFingerLabel(j) + 'Pinch';
                var pinchDistance = fh.DistanceBetweenFingers(hand.fingers[i], hand.fingers[j]);

                if (pinchDistance < 23) {
                    var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

                    bus.publish({
                        channel: "Input.Processed.Efficio",
                        topic: gestureName,
                        source: source,
                        data: {
                            input: data,
                            hand: hand,
                            pinchDistance: pinchDistance,
                            pinchFingersIndicies: [i, j],
                            gestureInformation: gestureInformation
                        }
                    });
                }
                else {
                    ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
                }
            }
        }
    };// END Pinch

    function ThumbsUp(hand, data) {
        var gestureName = side + 'ThumbsUp';
        if (hand.IsNeutral() && fh.AreRequisiteFingersExtended([0], hand)) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureInformation: gestureInformation
                }
            });
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    };// END ThumbsUp

    function ProcessInput(data, hand, agd) {
        // Hand information
        (function HandInformation() {
            side = hand.GetType();
        })();

        ActiveGesturesDictionary = agd;

        if (!oneHandPositionDetector) {
            oneHandPositionDetector = {
                Name: name,
                TrackingType: trackingType,
                Dictionary: dictionary,
                SubDictionary1: side,
                Positions: {
                    SideHandDetected: SideHandDetected,
                    SideHandCountFingersExtended: SideHandCountFingersExtended,
                    SideHandFingerDetected: SideHandFingerDetected,
                    SideHandFlexionDetected: SideHandFlexionDetected,
                    SideHandExtensionDetected: SideHandExtensionDetected,
                    SideHandRadialDeviation: SideHandRadialDeviation,
                    SideHandUlnarDeviation: SideHandUlnarDeviation,
                    SideHandSupenation: SideHandSupenation,
                    SideHandPronation: SideHandPronation,
                    SideHandHyperRotated: SideHandHyperRotated,
                    SideHandNeutral: SideHandNeutral,
                    SideHandFlexAndRotation: SideHandFlexAndRotation,
                    Pinch: Pinch,
                    ThumbsUp: ThumbsUp
                }
            }
        }

        for (var position in oneHandPositionDetector.Positions) {
            oneHandPositionDetector.Positions[position](hand, data);
        }

        return oneHandPositionDetector;
    }

    return {
        ProcessInput: ProcessInput
    }
});

﻿define('Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandGestureDetection',['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper', 'Helpers/Math'], function (bus, fh, math) {
    var source = 'Efficio Gesture Grimoire';
    var name = 'One Hand Gesture Detector';
    var dictionary = 'OneHandGesture';
    var trackingType = 'Hands';
    var side;
    var oneHandGestureDetector;
    var ActiveGesturesDictionary;

    function SideHandSwipe(hand, data) {
        var gestureName = side + 'HandSwipe';
        var isExecuting = false;
        var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

        if (hand.IsExtended() && hand.IsNeutral()) {
            if (typeof gestureInformation.ExtensionFramesCount === 'undefined') {
                gestureInformation.ExtensionFramesCount = 0;
                gestureInformation.PalmStartPosition = hand.palmPosition;
                gestureInformation.MiddleFingerStartPosition = hand.middleFinger.tipPosition;
                gestureInformation.StartFrame = hand.frame;

                setTimeout(function () {
                    isExecuting = false;
                }, 2000);
            } else {
                gestureInformation.ExtensionFramesCount++;
            }

            isExecuting = true;
        } else {
            if (gestureInformation.ExtensionFramesCount > 10 && hand.IsNeutral()) {
                if (typeof gestureInformation.NeutralFramesCount === 'undefined') {
                    gestureInformation.NeutralFramesCount = 0;
                } else {
                    gestureInformation.NeutralFramesCount++;
                }

                isExecuting = true;
            }
        }

        if (gestureInformation.ExtensionFramesCount > 10 && gestureInformation.NeutralFramesCount > 10 && hand.IsFlexed() && !gestureInformation.Fired) {
            gestureInformation.EndTime = new Date();
            gestureInformation.PalmEndPosition = hand.palmPosition;
            gestureInformation.MiddleFingerEndPosition = hand.middleFinger.tipPosition;
            gestureInformation.EndFrame = hand.frame;
            gestureInformation.SwipeVelocity = math.Velocity(gestureInformation.MiddleFingerStartPosition, gestureInformation.MiddleFingerEndPosition, gestureInformation.GestureDuration());
            gestureInformation.Fired = true;

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureInformation: gestureInformation
                }
            });

            setTimeout(function () {
                ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
            }, 250);
        }

        if (!isExecuting) {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary, side);
        }
    }

    function ProcessInput(data, hand, agd) {
        // Hand information
        (function HandInformation() {
            side = hand.type === 'right' ? 'Right' : 'Left';
        })();

        ActiveGesturesDictionary = agd;

        if (!oneHandGestureDetector) {
            oneHandGestureDetector = {
                Name: name,
                Gestures: {
                    SideHandSwipe: SideHandSwipe
                }
            }
        }

        for (gesture in oneHandGestureDetector.Gestures) {
            oneHandGestureDetector.Gestures[gesture](hand, data);
        }

        return oneHandGestureDetector;
    }

    return {
        ProcessInput: ProcessInput
    }
});

﻿define('Human Input Recognition and Processing/Hand Gestures/Two Hand Gestures/TwoHandPositionDetection',['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper', 'Helpers/Math'], function (bus, fh, math) {
    var source = 'Efficio Gesture Grimoire';
    var dictionary = 'TwoHandPosition';
    var FireCountMinimum = 15;
    var trackingType = 'Hands';
    var twoHandsGestureDetector;
    var ActiveGesturesDictionary;

    function BothHandsNeutral(data) {
        var hands = data.Input.hands;
        var gestureName = 'BothHandsNeutral'

        if (hands[0].IsNeutral() && hands[1].IsNeutral()) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary);

            if (gestureInformation.FireCount > FireCountMinimum) {
                gestureInformation.distance = math.DistanceBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);
                gestureInformation.midpoint = math.MidpointBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        gestureInformation: gestureInformation
                    }
                });
            }
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary);
        }
    };// END Both Hands Neutral

    function BothHandsPronation(data) {
        var hands = data.Input.hands;
        var gestureName = 'BothHandsPronation'

        if (hands[0].IsProne() && hands[1].IsProne()) {
            var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary);

            if (gestureInformation.FireCount > FireCountMinimum) {
                gestureInformation.distance = math.DistanceBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);
                gestureInformation.midpoint = math.MidpointBetweenTwoPoints(hands[0].palmPosition, hands[1].palmPosition);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hands,
                    }
                });
            }
        }
        else {
            ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName, dictionary);
        }
    };// END Both Hand Pronation

    function ProcessInput(data, agd) {
        ActiveGesturesDictionary = agd;

        if (!twoHandsGestureDetector) {
            twoHandsGestureDetector = {
                Name: name,
                Gestures: {
                    BothHandsNeutral: BothHandsNeutral,
                    BothHandsPronation: BothHandsPronation
                }
            };
        }


        for (var gesture in twoHandsGestureDetector.Gestures) {
            twoHandsGestureDetector.Gestures[gesture](data);
        }

        return twoHandsGestureDetector;
    }

    return {
        ProcessInput: ProcessInput
    }
});

﻿define('Human Input Recognition and Processing/Hand Gestures/HandGestureDetectionHandler',['postal'], function (bus) {
    var source = 'Efficio Gesture Grimoire';
    var name = 'Efficio Hand Gesture Detection Handler';
    var channel = 'Input.Processed.Efficio';
    var trackingType = "Hands";
    var handGestureDetectionLibrary = { Name: name };

    function ProcessInput(data, ActiveGesturesDictionary) {
        // Check if there is any input and if the input contains hands
        if (data.Input && data.Input.hands) {

            var hands = data.Input.hands;

            // Check if any hands are present
            (function NoHandsDetected() {
                var gestureName = 'NoHandsDetected'

                if (hands.length === 0) {
                    var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName)

                    bus.publish({
                        channel: channel,
                        topic: gestureName,
                        source: source,
                        data: {
                            message: 'No hands detected',
                            gestureInformation: gestureInformation
                        }
                    });

                    // Clear gesture dictionary for one and two hand gestures
                    ActiveGesturesDictionary.DeleteAllBut(trackingType, gestureName);

                    // No need for processing any further
                    return;
                }
                else {
                    ActiveGesturesDictionary.DeleteEntry(trackingType, gestureName);
                }
            })();

            // Detects each hand's presence independently
            if (hands.length > 0) {
                // Clear no hands entry
                ActiveGesturesDictionary.DeleteEntry(trackingType, 'NoHandsDetected');

                hands.forEach(function (hand) {
                    var gestureName = type + 'HandDetected';
                    var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName)

                    // Send Message saying what hand was detected
                    var type = hand.type;
                    bus.publish({
                        channel: channel,
                        topic: gestureName,
                        source: source,
                        data: {
                            hand: hand
                        }
                    });

                    // Send data to the one hand position gesture detection libraries
                    require(['Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandPositionDetection'], function (ohgd) {
                        handGestureDetectionLibrary.OneHandPositionDetector = ohgd.ProcessInput(data, hand, ActiveGesturesDictionary);
                    });

                    // Send data to the one hand gesture detection library
                    require(['Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandGestureDetection'], function (ohgd) {
                        handGestureDetectionLibrary.OneHandGestureDetector = ohgd.ProcessInput(data, hand, ActiveGesturesDictionary);
                    });
                });
            }

            // Check if one hand is present, clear opposite side
            (function OneHandDetected() {
                if (hands.length === 1) {
                    var hand = hands[0];
                    var oppositeHand = hand.type === 'right' ? 'Left' : 'Right'

                    // Clear other hand gesture dictionary entries
                    ActiveGesturesDictionary.DeleteEntry(trackingType, null, 'OneHandPosition', oppositeHand);
                    ActiveGesturesDictionary.DeleteEntry(trackingType, null, 'OneHandGesture', oppositeHand);
                    ActiveGesturesDictionary.DeleteEntry(trackingType, oppositeHand + 'HandDetected');
                }
            })();

            // Check if any hand present
            if (hands.length == 2) {
                (function TwoHandsDetected() {
                    if (hands.length === 2) {
                        var gestureName = 'TwoHandDetected'
                        var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName)

                        // Send Message saying that two hands were detected
                        bus.publish({
                            channel: channel,
                            topic: gestureName,
                            source: source,
                            data: {
                                gestureInformation: gestureInformation
                            }
                        });

                        // Send data to the two hand gesture detection library
                        require(['Human Input Recognition and Processing/Hand Gestures/Two Hand Gestures/TwoHandPositionDetection'], function (thgd) {
                            handGestureDetectionLibrary.TwoHandPositionDetector = thgd.ProcessInput(data, ActiveGesturesDictionary);
                        });
                    }
                    else {
                        ActiveGesturesDictionary.DeleteEntry(trackingType, 'TwoHandDetected');
                        ActiveGesturesDictionary.DeleteEntry(trackingType, null, 'TwoHandPosition');
                        ActiveGesturesDictionary.DeleteEntry(trackingType, null, 'TwoHandGesture');
                    }
                })();
            }
        }

        return handGestureDetectionLibrary;
    }


    return {
        ProcessInput: ProcessInput
    }
})
;
﻿define('Human Input Recognition and Processing/Input Extensions/Microsoft Kinect/KinectJointExtensions',[],function () {

    function IsAbove(joint1, joint2) {
        var result = DistanceAbove(joint1, joint2);
        return result > 0;
    }

    function IsBelow(joint1, joint2) {
        var result = DistanceBelow(joint1, joint2);
        return result > 0;
    }

    function IsRight(joint1, joint2) {
        var result = DistanceRight(joint1, joint2);
        return result > 0;
    }

    function IsLeft(joint1, joint2) {
        var result = DistanceLeft(joint1, joint2);
        return result > 0;
    }

    function IsForward(joint1, joint2) {
        var result = DistanceForward(joint1, joint2);
        return result > 0;
    }

    function IsBehind(joint1, joint2) {
        var result = DistanceBehind(joint1, joint2);
        return result > 0;
    }

    function DistanceAbove(joint1, joint2) {
        var result = joint2.Position.Y - joint1.Position.Y;
        return result;
    }

    function DistanceBelow(joint1, joint2) {
        var result = joint1.Position.Y - joint2.Position.Y;
        return result;
    }

    function DistanceRight(joint1, joint2) {
        var result = joint2.Position.X - joint1.Position.X;
        return result;
    }

    function DistanceLeft(joint1, joint2) {
        var result = joint1.Position.X - joint2.Position.X;
        return result;
    }

    function DistanceForward(joint1, joint2) {
        var result = joint2.Position.Z - joint1.Position.Z;
        return result;
    }

    function DistanceBehind(joint1, joint2) {
        var result = joint1.Position.Z - joint2.Position.Z;
        return result;
    }

    function ExtendClasses() {
        var extensions = {

            IsAbove: IsAbove,
            IsBelow: IsBelow,
            IsRight: IsRight,
            IsLeft: IsLeft,
            IsForward: IsForward,
            IsBehind: IsBehind,


            DistanceAboce: DistanceAbove,
            DistanceBelow: DistanceBelow,
            DistanceRight: DistanceRight,
            DistanceLeft: DistanceLeft,
            DistanceForward: DistanceForward,
            DistanceBehind: DistanceBehind

        }

        return extensions;
    }

    return {
        ExtendClasses: ExtendClasses
    }
})
;
﻿define('Human Input Recognition and Processing/Body Positions/BodyPositionDetectionHandler',['postal'], function (bus) {
    function ProcessInput(data, ActiveGesturesDictionary) {
        var source = 'Efficio Gesture Grimoire';
        var channel = 'Input.Processed.Efficio';
        var dictionary = 'BodyPosition';
        var trackingType = 'Body';
        var side;

        var jointHelper;
        var wristRight;
        var wristLeft;

        data.input.forEach(function (jointFriendly) {

            // Get the joints we are using to identify navigation
            if (jointFriendly.JointType == "WristRight") {
                wristRight = jointFriendly;
            }

            if (jointFriendly.JointType == "WristLeft") {
                wristLeft = jointFriendly;
            }

        });

        // only proceed with the checks if the joints are tracked
        if (wristRight.TrackingState == "Tracked" && wristLeft.TrackingState == "Tracked") {
            require(['../Input Extensions/Microsoft Kinect/KinectJointExtensions'], function (kje) {
                jointHelper = kje;
            });

            //// Check if Right Wrist is above Left Wrist
            //if (jointHelper.IsAbove(wristLeft, wristRight)) {
            //    var gestureName = "RightWristAboveLeftWrist"; 
            //    var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            //    bus.publish({
            //        channel: channel,
            //        topic: gestureName,
            //        source: source,
            //        data: {
            //            message: 'Right wrist above left wrist detected',
            //            gestureInformation: gestureInformation
            //        }
            //    });
            //}

            //// Check if Right Wrist is below Left Wrist
            //if (jointHelper.IsBelow(wristLeft, wristRight)) {
            //    var gestureName = "RightWristBelowLeftWrist";
            //    var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

            //    bus.publish({
            //        channel: channel,
            //        topic: gestureName,
            //        source: source,
            //        data: {
            //            message: 'Right wrist below left wrist detected',
            //            gestureInformation: gestureInformation
            //        }
            //    });
            //}

            // Check if Right Wrist is left of Left Wrist
            if (jointHelper.IsLeft(wristLeft, wristRight)) {
                var gestureName = "RightWristLeftOfLeftWrist";
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

                bus.publish({
                    channel: channel,
                    topic: gestureName,
                    source: source,
                    data: {
                        message: 'Right wrist left of left wrist detected',
                        gestureInformation: gestureInformation
                    }
                });
            }

            // Check if Right Wrist is right of Left Wrist
            if (jointHelper.IsRight(wristLeft, wristRight)) {
                var gestureName = "RightWristRightOfLeftWrist";
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

                bus.publish({
                    channel: channel,
                    topic: gestureName,
                    source: source,
                    data: {
                        message: 'Right wrist right of left wrist detected',
                        gestureInformation: gestureInformation
                    }
                });
            }

            // Check if Right Wrist is ahead of Left Wrist
            if (jointHelper.IsForward(wristLeft, wristRight)) {
                var gestureName = "RightWristAheadOfLeftWrist";
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

                bus.publish({
                    channel: channel,
                    topic: gestureName,
                    source: source,
                    data: {
                        message: 'Right wrist ahead of left wrist detected',
                        gestureInformation: gestureInformation
                    }
                });
            }

            // Check if Right Wrist is behind of Left Wrist
            if (jointHelper.IsBehind(wristLeft, wristRight)) {
                var gestureName = "RightWristBehindLeftWrist";
                var gestureInformation = ActiveGesturesDictionary.CreateOrUpdateEntry(trackingType, gestureName, dictionary, side);

                bus.publish({
                    channel: channel,
                    topic: gestureName,
                    source: source,
                    data: {
                        message: 'Right wrist behindleft wrist detected',
                        gestureInformation: gestureInformation
                    }
                });
            }


        }// end if for tracking check


    }


    return {
        ProcessInput: ProcessInput
    }
})
;
﻿define('Human Input Recognition and Processing/EfficioGestureGrimoire',['postal'], function (bus) {
    var source = 'Efficio Gesture Grimoire';
    var ActiveGesturesDictionary;
    var efficioGestureGrimoire = { Name: source };

    function DetectPredefinedGestures(data, envelope) {
        var trackingType = data.TrackingType || '';

        switch (trackingType) {
            case 'Hands': {
                require(['Human Input Recognition and Processing/Hand Gestures/HandGestureDetectionHandler'], function (hgdh) {
                    efficioGestureGrimoire.HandProcessor = hgdh.ProcessInput(data, ActiveGesturesDictionary)
                });
                break;
            }
            case 'Body': {
                // Body tracking library here
                require(['Human Input Recognition and Processing/Body Positions/BodyPositionDetectionHandler'], function (bpdh) {
                    bpdh.ProcessInput(data, ActiveGesturesDictionary)
                });
                break;
            }
            case 'Head': {
                // Head tracking library here
                break;
            }
            case 'Brain': {
                // Brain tracking library here
                break;
            }
            case 'Sensor': {
                // Other sensory input library here
                break;
            }
        }
    }



    return {
        Initialize: function (agd) {
            ActiveGesturesDictionary = agd;
            return efficioGestureGrimoire;
        },

        ProcessInput: function (data, envelope) {
            DetectPredefinedGestures(data, envelope);
        }
    }
});

﻿define('Human Input Recognition and Processing/HumanInputRecognitionAndProcessing',['postal', 'Human Input Recognition and Processing/ActiveGestureDictionary'], function (bus, agd) {

    var hipr = {  ActiveGesturesDictionary: agd, PrototypeExtensions: { }, };

    function Initialize() {
        // Extend input models for easier processing and to make them more informative
        (function LeapMotionPrototypeExtensions() {
            hipr.PrototypeExtensions.LeapMotion = {};

            require(['Human Input Recognition and Processing/Input Extensions/LeapMotion/LeapMotionHandExtensions'], function (LMHE) {
                hipr.PrototypeExtensions.LeapMotion.Hand = LMHE.ExtendClasses();
            });
        })();


        require(['Human Input Recognition and Processing/CustomGestureLibrariesAccess'], function (customGestureLibraries) {
            hipr.CustomGestureLibrary  = customGestureLibraries.Initialize(agd);

            bus.subscribe({
                channel: "Input.Raw",
                topic: "*",
                callback: function (data, envelope) {
                    customGestureLibraries.ProcessInput(data, envelope);
                }
            });
        }), function (err) {
            bus.publish({
                channel: 'UserNotification',
                topic: 'Warn',
                source: source,
                data: {
                    message: 'No custom gesture library configured'
                }
            });
        };

        require(['Human Input Recognition and Processing/EfficioGestureGrimoire'], function (efficioGestureLibrary) {
            hipr.EfficioGestureLibrary = efficioGestureLibrary.Initialize(agd);

            bus.subscribe({
                channel: "Input.Raw",
                topic: "*",
                callback: function (data, envelope) {
                    efficioGestureLibrary.ProcessInput(data, envelope);
                }
            });
        });

        //require(['Human Input Recognition and Processing/EfficioAudioGrimoire'], function (efficioAudioGrimoire) {
        //    efficioAudioGrimoire.Initialize();

        //    bus.subscribe({
        //        channel: "Input.Audio.Raw",
        //        topic: "*",
        //        callback: function (data, envelope) {
        //            efficioAudioGrimoire.ProcessInput(data, envelope);
        //        }
        //    });
        //});

        return hipr;
    }

    return {
        Initialize: Initialize
    }
});

﻿define('InternalScene',['THREE'], function () {
    var scene = new THREE.Scene();

    return {
        Initialize: function () {
        
        }, 
    
        Scene: scene
    }
});

﻿define('Asset Management and Inventory/AssetManager',['postal', 'InternalScene'], function (bus, internalScene) {
    var source = "Efficio Asset Manager"

    function CreateAsset(asset) {
        bus.publish({
            channel: "UserNotification",
            topic: "AssetCreated",
            source: source,
            data: {
                message: "Asset created with data: " + asset
            }
        });

        internalScene.Scene.add(asset);
    };

    function CreateAssets(assets) {

    };

    function RetrieveAsset(assetID) {

    };

    function RetrieveAssets(assetIDs) {

    };

    function RetrieveAllAssets() {

    };

    function RetrieveAllAssetIDs() {

    };

    function UpdateAsset(asset) {
        var oldAsset = internalScene.Scene.getObjectById(asset.id);

        internalScene.Scene.remove(oldAsset);
        internalScene.Scene.add(asset);

        asset = internalScene.Scene.getObjectById(asset.id);

        bus.publish({
            channel: "UserNotification",
            topic: "AssetUpdated",
            source: source,
            data: {
                message: source + " - Asset Updated: \nID: " + asset.id + "\nPosition: (" + asset.position.x + " , " + asset.position.y + ", " + asset.position.z + ")" + "\nScale: (" + asset.scale.x + " , " + asset.scale.y + ", " + asset.scale.z + ")"
            }
        });
    };

    function UpdateAssets(assets) {

    };

    function DeleteAsset(assetID) {

    };

    function DeleteAssets(assetIDs) {

    };

    function DeleteAllAssets() {

    };

    function GetValueForProperty(property, data) {
        switch (property) {
            case "ClosestAsset":
                {
                    return GetClosestAsset(data);
                }
        }
    }

    function GetClosestAsset(data) {
        if (data.location === null) {
            bus.publish({
                channel: "Exception.Efficio",
                topic: "GetClosestAsset",
                source: source,
                data: {
                    message: "GetClosestAsset function requires location argument"
                }
            });
        }
        return "Asset closest to point (" + data.Location.x + ", " + data.Location.y + ", " + data.Location.z + ")"
    }

    return {
        Initialize: function () {
            if (typeof window != 'undefined') {
                //var http = new XMLHttpRequest();
                //http.open('HEAD', '/debug.html', false);
                //http.send();

                //if (http.status != 404) {
                //    var params = [
                //        'height=' + screen.height,
                //        'width=' + screen.width,
                //        'fullscreen=yes' // only works in IE, but here for completeness
                //    ].join(',');

                //    window.open('/debug.html', 'AMI Debugger', params);
                //}
            }
        },

        CreateAsset: CreateAsset,

        CreateAssets: CreateAssets,

        RetrieveAsset: RetrieveAsset,

        RetrieveAssets: RetrieveAssets,

        RetrieveAllAssets: RetrieveAllAssets,

        RetrieveAllAssetIDs: RetrieveAllAssetIDs,

        UpdateAsset: UpdateAsset,

        UpdateAssets: UpdateAssets,

        DeleteAsset: DeleteAsset,

        DeleteAssets: DeleteAssets,

        DeleteAllAssets: DeleteAllAssets,

        GetValueForProperty: GetValueForProperty,

    }
});

﻿define('Constraints Engine/ConstraintsEngine',['postal', 'Asset Management and Inventory/AssetManager'], function (bus, ami) {
    var source = "Efficio Constraints Engine";
    var violated = false;

    var subscriptions = new Array();

    function RegisterSubscriber(subscription) {
        subscriptions.push(subscription);
    }

    function CheckConstraints(data) {
        //if (violated) {
        //    console.log('Constraints violated, changes not reflected internally.')
        //}
        //else {
        //    console.log('Constraints not violated, changes reflected internally.')
        //}

        return true;
    }

    return{
        Initialize: function () {

        }
    };
});

﻿define('Command Issuance and Control/CommandIssuanceAndControl',['postal', 'Asset Management and Inventory/AssetManager'], function (bus, ami) {
    return {
        Initialize: function () {
            var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
            var ARGUMENT_NAMES = /([^\s,]+)/g;

            function getParamNames(func) {
                var fnStr = func.toString().replace(STRIP_COMMENTS, '');
                var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
                if (result === null)
                    result = [];
                return result;
            }

            ActionToFunctionMapping.ActionMappings.forEach(function (mapping) {
                bus.subscribe({
                    channel: mapping.Source,
                    topic: mapping.Topic,
                    callback: function (data, envelope) {
                        var func = mapping.Action;

                        if (typeof func != 'function') {
                            func = ActionToFunctionMapping.Bridge[mapping.Action];
                        }

                        // Get method parameters
                        var functionParameters = getParamNames(func);

                        var argMapping = {};

                        // Create args for function call
                        var args = [];

                        if (mapping.Arguments) {
                            functionParameters.forEach(function (param) {
                                var params = mapping.Arguments.filter(function (argument) {
                                    return argument.MapTo === param;
                                });

                                if (params.length > 0) {
                                    var value;

                                    if (params[0].Source && params[0].Source === 'AssetManager') {
                                        value = ami.GetValueForProperty(params[0].Name, data);
                                    }
                                    else {
                                        value = data[params[0].Name];
                                    }

                                    args.push(value);
                                }
                                else {
                                    args.push(null);
                                }
                            });

                            args[args.length] = data;
                        }
                        else {
                            args = [data];
                        }

                        if (mapping.FireRestrictions) {
                            var execute = [];
                            var restrictions = mapping.FireRestrictions;
                            if (restrictions.FireOnce) {
                                if (data.gestureInformation.Fired) {
                                    return;
                                }
                            }

                            if (restrictions.FireAfterXFrames) {
                                if (data.gestureInformation.FireCount < restrictions.FireAfterXFrames) {
                                    return;
                                }
                            }
                        }

                        func.apply(null, args);

                        if (data.gestureInformation) {
                            data.gestureInformation.Fired = true;
                        }
                    }
                })
            });
        }
    };
});

﻿define('Logging/SystemNotificationListener',['postal'], function (bus) {
    return {
        Initialize: function () {
            bus.subscribe({
                channel: "SystemNotification",
                topic: "*",
                callback: function (data, envelope) {
                    console.log(envelope.topic + ": " + data.message);
                }
            });
        }
    }
});

﻿define('Input/DeviceManager',['postal'], function (bus) {
    var Efficio;
    var Devices = {};

    function Add(name, device) {
        Devices[name] = device;

        bus.publish({
            channel: 'Devices',
            topic: 'Added',
            source: name,
            data: {
                Name: name,
                Device: device
            }
        });
    }

    function Remove(name) {
        Devices[name] = null;

        bus.publish({
            channel: 'Devices',
            topic: 'Removed',
            source: name,
            data: {
                Name: name
            }
        });
    }

    function Initialize(Efficio) {
        return Devices;
    }

    return {
        Add: Add,
        Remove: Remove,
        Initialize: Initialize,
        Devices: Devices
    }
});

﻿define('Metrics/Metrics',[],function () {
    var startTime;
    var framesSinceStart = 0;
    var Metrics = {};

    function incrementFrames() {
        framesSinceStart++;
        requestAnimationFrame(incrementFrames);
    }

    function AverageFPS() {
        return framesSinceStart / (UpTime() / 1000);
    }

    function UpTime() {
        return new Date() - startTime;
    }

    function Initialize() {
        Metrics.AverageFPS = AverageFPS;
        Metrics.UpTime = UpTime;

        return Metrics;
    }

    function Start() {
        startTime = new Date();

        if (window) {
            requestAnimationFrame(incrementFrames);
        }
    }

    return {
        Initialize: Initialize,
        Start: Start
    }
});

﻿define('Input/LeapMotion/LeapMotion',['postal', 'leapjs', 'Input/DeviceManager'], function (bus, Leap, deviceManager) {
    var source = 'Leap Motion';
    var trackingType = 'Hands';
    var controller;

    function configure(EfficioConfiguration) {
        var LeapConfiguration = EfficioConfiguration.Devices.LeapMotion;
        LeapConfiguration = {
            Host: LeapConfiguration.Host || 'localhost',
            Port: LeapConfiguration.Port || 6437,
            EnableGestures: LeapConfiguration.EnableGestures || false,
            FrameEventName: LeapConfiguration.FrameEventName || 'animationFrame',
            UseAllPlugins: LeapConfiguration.UseAllPlugins || false
        }

        return LeapConfiguration;
    }

    return {
        Initialize: function (LeapConfiguration) {

            // Load Configuration
            LeapConfiguration = configure(LeapConfiguration);

            // Create Controller
            controller = new Leap.Controller({
                host: LeapConfiguration.Host,
                port: LeapConfiguration.Port,
                enableGestures: LeapConfiguration.EnableGestures,
                frameEventName: LeapConfiguration.FrameEventName,
                useAllPlugins: LeapConfiguration.UseAllPlugins
            });

            // Register Leap Motion's native gesture recognition
            controller.on("gesture", function (gesture) {
                if (gesture.state == "stop") {
                    bus.publish({
                        channel: 'Input.Raw',
                        topic: 'Gesture',
                        source: source,
                        data: {
                            Name: gesture.type,
                            Gesture: gesture
                        }
                    });
                }
            });

            controller.connect();

            // Add Leap Motion to Device Manager
            deviceManager.Add(source, controller);
            deviceManager.Devices[source].IsConnected = function () {
                return controller.connected();
            }
        },

        Start: function () {

            // Listens for input from device
            controller.loop(function (frame) {
                if (frame.valid) {
                    bus.publish({
                        channel: 'Input.Raw',
                        topic: 'Leap',
                        source: source,
                        data: {
                            TrackingType: trackingType,
                            Input: frame
                        }
                    });
                }
            });
        }
    }
});

﻿define('Input/Microsoft Kinect/JointHelper',[],function () {

    // Reference https://msdn.microsoft.com/en-us/library/microsoft.kinect.jointtype.aspx for joint numbering
    // Joints are entered into the array based on numerical order

    var joints = ["SpineBase", "SpineMid", "Neck", "Head", "ShoulderLeft", "ElbowLeft", "WristLeft", "HandLeft", "ShoulderRight", "ElbowRight", "WristRight", "HandRight", "HipLeft", "KneeLeft", "AnkleLeft", "FootLeft", "HipRight", "KneeRight", "AnkleRight", "FootRight", "SpineShoulder", "HandTipLeft", "ThumbLeft", "HandTipRight", "ThumbRight"];

    function GetJointName(jointNumber) {
        return joints[jointNumber];
    }

    var jointTrackingStatus = ["NotTracked", "Inferred", "Tracked"];

    function GetJointTrackingStatus(trackNumber) {
        return jointTrackingStatus[trackNumber];
    }

    return {
        GetJointName: GetJointName ,

        GetJointTrackingStatus:GetJointTrackingStatus
    }
})
;
﻿define('Input/Microsoft Kinect/Kinect',['postal', 'Input/DeviceManager'], function (bus, deviceManager) {
    var source = 'Microsoft Kinect';
    var TrackingType = 'Body';
    var controller;
    var device = "Kinect";
    var jointHelper;

    function configure(KinectConfiguration) {
        KinectConfiguration = {
            Host: KinectConfiguration.Host || "ws://localhost:8181"
        }

        return KinectConfiguration;
    }

    return {
        Initialize: function (KinectConfiguration) {

            // Retrieve Joint Helper
            require(['Input/Microsoft Kinect/JointHelper'], function (jh) {
                jointHelper = jh;
            });

            // Load Configuration
            KinectConfiguration = configure(KinectConfiguration);

            // Create Controller
            controller = new WebSocket(KinectConfiguration.Host);

           

            // Sends message when controller is connected
            controller.onopen = function ()
            {
                console.log("Connection successful.");

                // ISMAEL: Device connection notification has been migrated to the Device Manager. Use the leap motion input as an example on how to use it
                // Add WebSocket to Device Manager
                deviceManager.Add(source, controller);
                deviceManager.Devices[source].IsConnected = function () {
                    return true;
                }
                
            };

            // Connection closed.
            controller.onclose = function () {
                    console.log("Connection closed.");

            }
        },

        Start: function () {

            // Listens for input from device
            controller.onmessage = function (frame)
            {
                var kinectFriendly = [];
               
               var skeleton = JSON.parse(frame.data);
               skeleton.Joints.forEach(function (joint)
               {
                   // Get the Joint Type and Tracking Status
                   var jointType = jointHelper.GetJointName(joint.JointType);
                   var jointTracking = jointHelper.GetJointTrackingStatus(joint.TrackingState);
                   var jointFriendly = { JointType: jointType, TrackingState: jointTracking, Joint: joint };

                   kinectFriendly.push(jointFriendly);
               });

               // ISMAEL: Consider just extending the joint object. Eliminate the need for object copying.
               //skeleton.Joints.forEach(function (joint) {
               //    // Get the Joint Type and Tracking Status
               //    joint.FriendlyName = jointHelper.GetJointName(joint.JointType);
               //    joint.TrackingStatus = jointHelper.GetJointTrackingStatus(joint.TrackingState);
               //});

               // ISMAEL: Tell me if you think this would be a useful function to expose
               //skeleton.FindJointByFriendlyName = function (friendlyName) {
               //    var returnJoint = this.Joints.filter(function (value) {
               //        value.FriendlyName === friendlyName
               //    });

               //    if (returnJoint && returnJoint.lenght > 0) {
               //        return returnJoint[0];
               //    }

               //    return null;
               //}

                bus.publish
                ({
                    channel: 'Input.Raw',
                    topic: device,
                    source: source,
                    data:
                    {
                        TrackingType: TrackingType,
                        input: kinectFriendly
                    }
                });
            };
        }
    }
});

﻿define('Input/Microphone/Microphone',['postal', 'annyang', 'Input/DeviceManager'], function (bus, annyang, deviceManager) {

    var source = 'Microphone';

    function Initialize(LeapConfiguration) {

        if (typeof ActionToFunctionMapping.AudioCommands != 'undefined') {
            // Add our commands to annyang
            annyang.addCommands(ActionToFunctionMapping.AudioCommands);
        }

        // Add microphone to Device Manager
        deviceManager.Add(source, annyang);
    }

    function Start() {
        annyang.start();
    }

    return {
        Intitialize: Initialize,
        Start: Start
    }
});

﻿define('Input/Accelerometer/Browser2',['postal', 'Input/DeviceManager'], function (bus, deviceManager) {
    var source = "Accelerometer"
    var trackingType = 'Orientation';
    var started = false;

    function Initialize(EfficioConfiguration) {
        // Listen for orientation changes
        window.addEventListener("deviceorientation", function (event) {
            if (started) {
                bus.publish({
                    channel: 'Input.Raw',
                    topic: 'Device Orientation',
                    source: source,
                    data: {
                        TrackingType: trackingType,
                        DeviceOrientation: event
                    }
                });
            }
        }, false);

        window.addEventListener("orientationchange", function () {
            if (started) {
                bus.publish({
                    channel: 'Input.Raw',
                    topic: 'Orientation Change',
                    source: source,
                    data: {
                        TrackingType: trackingType,
                        DeviceOrientation: window.orientation || 0
                    }
                });
            }
        }, false);
    }

    function Start() {
        started = true;
        deviceManager.Add(source, { started: true });
    }

    return {
        Initialize: Initialize,
        Start: Start
    }

});

﻿define('Input/Geolocation/Browser',['postal', 'Input/DeviceManager'], function (bus, deviceManager) {
    var source = "Geolocaiton"
    var trackingType = 'Location';
    var enabled = false;

    function getGeolocation() {
        navigator.geolocation.getCurrentPosition(publishPosition);
        window.requestAnimationFrame(getGeolocation);
    }

    function publishPosition(location) {
        bus.publish({
            channel: 'Input.Raw',
            topic: 'Location',
            source: source,
            data: {
                TrackingType: trackingType,
                Location: location
            }
        });
    }

    function Initialize(EfficioConfiguration) {
        if (window.navigator) {
            if (navigator.geolocation) {
                enabled = true;
            }
        }
    }

    function Start() {
        if (enabled) {
            window.requestAnimationFrame(getGeolocation);
        }
    }

    return {
        Initialize: Initialize,
        Start: Start
    }
});

﻿define('Efficio',[
    'Human Input Recognition and Processing/HumanInputRecognitionAndProcessing',
    'Asset Management and Inventory/AssetManager',
    'Constraints Engine/ConstraintsEngine',
    'Command Issuance and Control/CommandIssuanceAndControl',
    'InternalScene',
    'Logging/SystemNotificationListener',
    'Input/DeviceManager',
    'Metrics/Metrics'
    //'Sequence Execution and Action Scheduling/CollisionDetectionAndGravitySimulation',
],

function (hirp, ami, constraintsEngine, comm, internalScene, sysNotificationListener, deviceManager, metrics) {
    var Efficio;

    function configure(EfficioConfiguration) {
        EfficioConfiguration.Devices = EfficioConfiguration.Devices || { Microphone: false, Kinect: false, LeapMotion: false };
        EfficioConfiguration.Debug = EfficioConfiguration.Debug || false;

        Efficio.Configuration = EfficioConfiguration;
    }

    return {
        Initialize: function (EfficioConfiguration) {

            if (typeof Efficio === 'undefined' || Efficio === null) {
                Efficio = {};
            }

            if (window && (window.Efficio === null || typeof window.Efficio === 'undefined')) {
                window.Efficio = Efficio
            }

            configure(EfficioConfiguration);

            Efficio.Metrics = metrics.Initialize();

            Efficio.HumanInputAndGestureRecognition =  hirp.Initialize();
            ami.Initialize();
            constraintsEngine.Initialize();
            comm.Initialize();
            internalScene.Initialize();
            sysNotificationListener.Initialize();
            Efficio.DeviceManager = deviceManager.Initialize();

            if (EfficioConfiguration.Devices.LeapMotion) {
                require(['Input/LeapMotion/LeapMotion'], function (leap) {
                    leap.Initialize(EfficioConfiguration);
                    leap.Start();
                });
            }

            // JAMES -- I had to change this to get it to work
            if (EfficioConfiguration.Devices.Kinect) {
                require(['Input/Microsoft Kinect/Kinect'], function (kinect) {
                    kinect.Initialize(EfficioConfiguration);
                    kinect.Start();
                });
            }

            if (EfficioConfiguration.Devices.Microphone) {
                require(['Input/Microphone/Microphone'], function (microphone) {
                    microphone.Intitialize();
                    microphone.Start();
                });
            }

            if (window) {
                // Accelerometer
                require(['Input/Accelerometer/Browser2'], function (browser) {
                    browser.Initialize(EfficioConfiguration);
                    browser.Start();
                })

                require(['Input/Geolocation/Browser'], function (browser) {
                    browser.Initialize(EfficioConfiguration);
                    browser.Start();
                })
            }
        },
        Start: function () {
            metrics.Start();
        }
    }
});

﻿if (typeof THREE === 'object') {
    define('THREE', function () { return THREE; });
}

if (typeof Leap === 'function') {
    define('leapjs', function () { return Leap; });
}

require(["Efficio"], function (Efficio) {
    Efficio.Initialize(EfficioConfiguration);
    Efficio.Start();
});

define("main", function(){});

