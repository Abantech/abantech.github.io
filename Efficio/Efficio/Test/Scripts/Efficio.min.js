define('Message Bus/MessageBus',['postal'], function (bus) {
    return {
        Initialize: function () {
            // Any bus configuration here
        },
        Bus: bus
    }
});

﻿define('Human Input Recognition and Processing/CustomGestureLibrariesAccess',['postal'], function (bus) {
    var source = 'Custom Gesture Libraries';
    var ActiveGesturesDictionaryCopy = {};

    function LoadCustomGestures() {
        // Custom Gestures created by the user will be loaded here
    }

    function DetectCustomGestures(data, envelope) {
        var libraryName = 'custom library 1';
        var gestureName = 'my custom gesture';
        var gestureData = 'my custom gesture data';

        // If custom gesture is detected
        if (data.input === 'BVH representation of a custom gesture') {

            bus.publish({
                channel: "Input.Processed.Custom." + libraryName,
                topic: gestureName,
                source: source,
                data: gestureData
            });
        }
    }

    return {
        Initialize: function (ActiveGesturesDictionary) {
            ActiveGesturesDictionaryCopy = ActiveGesturesDictionary;
        },
        ProcessInput: function (data, envelope) {

            // Where input is processed and Custom Gestures are published on the channel
            DetectCustomGestures(data, envelope);
        }
    }
})
;
﻿define('Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper',[],function () {
    var configuration = {
        ExtensionMeasure: .5,
        FlexionMeasure: -.5,
        SupinationMeasure: 145,
        PronationMeasure: {
            Min: -35,
            Max: 35
        },
        UlnarDeviationMeasure: .5,
        RadialDeviationMeasure: -.2,
    };

    function Configure(config) {
        configuration.ExtensionMeasure == config.ExtensionMeasure || configuration.ExtensionMeasure;
        configuration.FlexionMeasure == config.FlexionMeasure || configuration.FlexionMeasure;
        configuration.SupinationMeasure == config.SupinationMeasure || configuration.SupinationMeasure;
        configuration.UlnarDeviationMeasure == config.UlnarDeviationMeasure || configuration.UlnarDeviationMeasure;
        configuration.RadialDeviationMeasure == config.RadialDeviationMeasure || configuration.RadialDeviationMeasure;
    }

    function GetSide(hand) {
        return hand.type === 'right' ? 'Right' : 'Left';
    }

    function GetAngle(hand) {
        return hand.direction[1];
    }

    function Neutral(hand) {
        var neutral;

        if (!Supination(hand) && !Pronation(hand) && !HyperPronation(hand)) {
            neutral = { };
        }

        return neutral;
    }

    function Extension(hand) {
        var extension;
        var measure = hand.direction[1] - hand.arm.direction()[1];

        if (measure > configuration.ExtensionMeasure) {
            extension = {
                TBD: measure
            }
        }

        return extension;
    }

    function Flexion(hand) {
        var flexion;
        var measure = hand.direction[1] - hand.arm.direction()[1];

        if (measure < configuration.FlexionMeasure) {
            flexion = {
                TBD: measure
            }
        }

        return flexion;
    }

    function Supination(hand) {
        var supination;
        var measure = hand.roll() * (180 / Math.PI);
        measure = GetSide(hand) === 'Right' ? -measure : measure;

        if (measure > configuration.SupinationMeasure) {
            supination = {
                TBD: measure
            }
        }

        return supination;
    }

    function Pronation(hand) {
        var pronation;
        var measure = hand.roll() * (180 / Math.PI);
        measure = GetSide(hand) === 'Right' ? -measure : measure;

        if (measure > configuration.PronationMeasure.Min && measure < configuration.PronationMeasure.Max) {
            pronation = {
                TBD: measure
            }
        }

        return pronation;
    }

    function HyperPronation(hand) {
        var pronation;
        var measure = hand.roll() * (180 / Math.PI);
        measure = GetSide(hand) === 'Right' ? -measure : measure;

        if (measure < configuration.PronationMeasure.Min) {
            pronation = {
                TBD: measure
            }
        }

        return pronation;
    }

    function UlnarDeviation(hand) {
        var deviation;
        var measure = GetSide(hand) === 'Right' ? hand.direction[0] - hand.arm.direction()[0] : -1 * hand.direction[0] - (-1) * hand.arm.direction()[0];

        if (measure > configuration.UlnarDeviationMeasure) {
            deviation = {
                TBD: measure
            }
        }

        return deviation;
    }

    function RadialDeviation(hand) {
        var deviation;
        var measure = GetSide(hand) === 'Right' ? hand.direction[0] - hand.arm.direction()[0] : -1 * hand.direction[0] - (-1) * hand.arm.direction()[0];

        if (measure < configuration.RadialDeviationMeasure) {
            deviation = {
                TBD: measure
            }
        }

        return deviation;
    }

    return {
        Configure: Configure,
        GetSide: GetSide,
        GetAngle: GetAngle,
        Neutral: Neutral,
        Extension: Extension,
        Flexion: Flexion,
        Supination: Supination,
        Pronation: Pronation,
        HyperPronation: HyperPronation,
        UlnarDeviation: UlnarDeviation,
        RadialDeviation: RadialDeviation
    }
})
;
﻿define('Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper',[],function () {
    var fingerCountLabelsMap = ["Zero", "One", "Two", "Three", "Four", "Five"];
    var fingerNameLabelMap = ["Thumb", "Index", "Middle", "Ring", "Pinky"];

    function GetExtendedFingers(hand){
        return hand.fingers.filter(function (finger) {
            return finger.extended;
        });
    }

    function GetExtendedFingersIndicies(hand) {
        return hand.fingers.filter(function (finger) {
            return finger.extended;
        }).map(function (finger) {
            return finger.type
        });
    }

    function GetFingerLabel(fingerIndex) {
        return fingerNameLabelMap[fingerIndex];
    }

    function GetExtendedFingersCount(hand) {
        return GetExtendedFingers(hand).length;
    }

    function GetExtendedFingersCountLabel(hand) {
        return fingerCountLabelsMap[GetExtendedFingersCount(hand)];
    }

    function AreRequisiteFingersExtended(hand, neededFingersArray) {
        var extendedFingers = GetExtendedFingers(hand);

        return extendedFingers.filter(function (n) {
            return neededFingersArray.indexOf(n) != -1
        }).length === neededFingersArray.length;
    }
    
    function DistanceBetweenFingers(finger1, finger2) {
        var finger1Tip = finger1.tipPosition;
        var finger2Tip = finger2.tipPosition;
        var x2 = finger1Tip[0];
        var y2 = finger1Tip[1];
        var z2 = finger1Tip[2];
        var x1 = finger2Tip[0];
        var y1 = finger2Tip[1];
        var z1 = finger2Tip[2];

        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1))
    }

    return {
        GetExtendedFingers: GetExtendedFingers,
        GetExtendedFingersIndicies: GetExtendedFingersIndicies,
        GetFingerLabel: GetFingerLabel,
        GetExtendedFingersCount: GetExtendedFingersCount,
        GetExtendedFingersCountLabel: GetExtendedFingersCountLabel,
        AreRequisiteFingersExtended: AreRequisiteFingersExtended,
        DistanceBetweenFingers: DistanceBetweenFingers
    }
})
;
﻿define('Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandGestureDetection',['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper'], function (bus, hh, fh) {
    function ProcessInput(data, hand, ActiveGesturesDictionary) {
        var source = 'Efficio Gesture Grimoire';
        var dictionary = 'OneHandGesture';

        // Hand information
        var side = hh.GetSide(hand);

        if (!ActiveGesturesDictionary[dictionary]) {
            ActiveGesturesDictionary[dictionary] = {};
        }

        if (!ActiveGesturesDictionary[dictionary][side]) {
            ActiveGesturesDictionary[dictionary][side] = {};
        }

        /*
          Name:           {Side} Hand Detected
   
          Outputs:        RightHandDetected
                          LeftHandDetected
           
          Description:    Informs consumer how many fingers fingers are extended and on which hand 
       */
        (function SideHandCountFingersExtended() {
            var gestureName = side + 'HandDetected';

            if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                ActiveGesturesDictionary[dictionary][side][gestureName] = {
                    StartTime: new Date()
                }
            }

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: gestureName,
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                }
            });
        })();

        /*
          Name:           {Side} Hand {Count} Fingers Extended
   
          Outputs:        RightHandZeroFingersExtended
                          RightHandOneFingersExtended
                          RightHandTwoFingersExtended
                          RightHandThreeFingersExtended
                          RightHandFourFingersExtended
                          RightHandFiveFingersExtended
                          LeftHandZeroFingersExtended
                          LeftHandOneFingersExtended
                          LeftHandTwoFingersExtended
                          LeftHandThreeFingersExtended
                          LeftHandFourFingersExtended
                          LeftHandFiveFingersExtended
           
          Description:    Informs consumer how many fingers fingers are extended and on which hand 
       */
        (function SideHandCountFingersExtended() {
            var extendedFingerCountLabel = fh.GetExtendedFingersCountLabel(hand);
            var extendedFingersIndicies = fh.GetExtendedFingersIndicies(hand);

            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: side + 'Hand' + extendedFingerCountLabel + 'FingersExtended',
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    extendedFingers: extendedFingersIndicies
                }
            });
        })(); // END {Side} Hand {Count} Fingers Extended

        /*
           Name:           {Side} Hand {Finger} Extended
   
           Outputs:        RightHandThumbFingerExtended
                           RightHandIndexFingerExtended
                           RightHandMiddleFingerExtended
                           RightHandRingFingerExtended
                           RightHandPinkyFingerExtended
                           LeftHandThumbFingerExtended
                           LeftHandIndexFingerExtended
                           LeftHandMiddleFingerExtended
                           LeftHandRingFingerExtended
                           LeftHandPinkyFingerExtended
           
           Description:    Informs consumer which fingers are extended and on which hand 
       */
        (function SideHandFingerDetected() {
            hand.fingers.forEach(function (finger) {
                var fingerName = fh.GetFingerLabel(finger.type);
                var gestureName = side + 'Hand' + fingerName + 'FingerExtended'

                if (finger.extended) {

                    if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                        ActiveGesturesDictionary[dictionary][side][gestureName] = {
                            StartTime: new Date()
                        }
                    }

                    bus.publish({
                        channel: "Input.Processed.Efficio",
                        topic: gestureName,
                        source: source,
                        data: {
                            input: data,
                            hand: hand,
                            finger: finger.type,
                            gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                        }
                    });
                }
                else {
                    ActiveGesturesDictionary[dictionary][side][gestureName] = null;
                }
            });
        })(); // END {Side} Hand {Finger} Extended

        /*
            Name:           {Side} Hand Flexion Detected
    
            Outputs:        RightHandFlexion
                            LeftHandFlexion
        */
        (function SideHandFlexionDetected() {
            var gestureName = side + 'HandFlexion'
            var flexion = hh.Flexion(hand);
            if (flexion) {

                if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                    ActiveGesturesDictionary[dictionary][side][gestureName] = {
                        StartTime: new Date()
                    }
                }

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        flexion: flexion,
                        gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                    }
                });
            }
            else {
                ActiveGesturesDictionary[dictionary][side][gestureName] = null;
            }
        })();// END {Side} Hand Flexion

        /*
            Name:           {Side} Hand Extension Detected
    
            Outputs:        RightHandExtension
                            LeftHandExtension
        */
        (function SideHandExtensionDetected() {
            var gestureName = side + 'HandExtension'
            var extension = hh.Extension(hand);
            if (extension) {
                if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                    ActiveGesturesDictionary[dictionary][side][gestureName] = {
                        StartTime: new Date()
                    }
                }

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        extension: extension,
                        gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                    }
                });
            }
            else {
                ActiveGesturesDictionary[dictionary][side][gestureName] = null;
            }
        })();// END {Side} Hand Extension

        /*
            Name:           {Side} Hand Radial Deviation

            Outputs:        RightHandRadialDeviation
                            LeftHandRadialDeviation
        */
        (function SideHandRadialDeviation() {
            var gestureName = side + 'HandRadialDeviation'
            var deviation = hh.RadialDeviation(hand);
            if (deviation) {

                if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                    ActiveGesturesDictionary[dictionary][side][gestureName] = {
                        StartTime: new Date()
                    }
                }

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        deviation: deviation,
                        gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                    }
                });
            }
            else {
                ActiveGesturesDictionary[dictionary][side][gestureName] = null;
            }
        })();// END {Side} Hand Radial Deviation

        /*
            Name:           {Side} Hand Ulnar Deviation

            Outputs:        RightHandUlnarDeviation
                            LeftHandUlnarDeviation
        */
        (function SideHandUlnarDeviation() {
            var gestureName = side + 'HandUlnarDeviation'
            var deviation = hh.UlnarDeviation(hand);
            if (deviation) {
                if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                    ActiveGesturesDictionary[dictionary][side][gestureName] = {
                        StartTime: new Date()
                    }
                }

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        deviation: deviation,
                        gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                    }
                });
            }
            else {
                ActiveGesturesDictionary[dictionary][side][gestureName] = null;
            }
        })();// END {Side} Hand Ulnar Deviation

        /*
            Name:           {Side} Hand Supenation

            Outputs:        RightHandSupenation
                            LeftHandSupenation
        */
        (function SideHandSupenation() {
            var gestureName = side + 'HandSupenation'
            var supenation = hh.Supination(hand);
            if (supenation) {
                if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                    ActiveGesturesDictionary[dictionary][side][gestureName] = {
                        StartTime: new Date()
                    }
                }

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        supenation: supenation,
                        gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                    }
                });
            }
            else {
                ActiveGesturesDictionary[dictionary][side][gestureName] = null;
            }
        })();// END {Side} Hand Supenation

        /*
            Name:           {Side} Hand Pronation

            Outputs:        RightHandPronation
                            LeftHandPronation
        */
        (function SideHanPronation() {
            var gestureName = side + 'HandPronation'
            var pronation = hh.Pronation(hand);
            if (pronation) {
                if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                    ActiveGesturesDictionary[dictionary][side][gestureName] = {
                        StartTime: new Date()
                    }
                }

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        pronation: pronation,
                        gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                    }
                });
            }
            else {
                ActiveGesturesDictionary[dictionary][side][gestureName] = null;
            }
        })();// END {Side} Hand Pronation

        /*
           Name:           {Side} Hand Hyper Pronation

           Outputs:        RightHandHyperPronation
                           LeftHandHyperPronation
       */
        (function SideHandHyperPronation() {
            var gestureName = side + 'HandHyperPronation'
            var pronation = hh.HyperPronation(hand);
            if (pronation) {
                if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                    ActiveGesturesDictionary[dictionary][side][gestureName] = {
                        StartTime: new Date()
                    }
                }

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        pronation: pronation,
                        gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                    }
                });
            }
            else {
                ActiveGesturesDictionary[dictionary][side][gestureName] = null;
            }
        })();// END {Side} Hand Hyper Pronation

        /*
           Name:           {Side} Hand Neutral

           Outputs:        RightHandNeutral
                           LeftHandNeutral
        */
        (function SideHandNeutral() {
            var gestureName = side + 'HandNeutral'
            var neutral = hh.Neutral(hand);
            if (neutral) {
                if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                    ActiveGesturesDictionary[dictionary][side][gestureName] = {
                        StartTime: new Date()
                    }
                }

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        neutral: neutral,
                        gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                    }
                });
            }
            else {
                ActiveGesturesDictionary[dictionary][side][gestureName] = null;
            }
        })();// END {Side} Hand Neutral

        (function Pinch() {
            for (var i = 0; i < hand.fingers.length - 1; i++) {
                for (var j = i + 1; j < hand.fingers.length; j++) {
                    var gestureName = side + 'Hand' + fh.GetFingerLabel(i) + fh.GetFingerLabel(j) + 'Pinch';
                    var pinchDistance = fh.DistanceBetweenFingers(hand.fingers[i], hand.fingers[j]);

                    if (pinchDistance < 23) {
                        if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                            ActiveGesturesDictionary[dictionary][side][gestureName] = {
                                StartTime: new Date()
                            }
                        }

                        bus.publish({
                            channel: "Input.Processed.Efficio",
                            topic: gestureName,
                            source: source,
                            data: {
                                input: data,
                                hand: hand,
                                pinchDistance: pinchDistance,
                                pinchFingersIndicies: [i, j],
                                gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                            }
                        });
                    }
                    else {
                        ActiveGesturesDictionary[dictionary][side][gestureName] = null;
                    }
                }



                if (true) {

                }
            }
        })();// END Pinch

        (function ThumbsUp() {
            var gestureName = side + 'ThumbsUp';
            if (hh.Neutral(hand) && fh.AreRequisiteFingersExtended([0], hand)) {
                if (!ActiveGesturesDictionary[dictionary][side][gestureName]) {
                    ActiveGesturesDictionary[dictionary][side][gestureName] = {
                        StartTime: new Date()
                    }
                }

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        pinchDistance: pinchDistance,
                        pinchFingersIndicies: [i, j],
                        gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][side][gestureName].StartTime - new Date()) / 1000)
                    }
                });
            }
            else {
                ActiveGesturesDictionary[dictionary][side][gestureName] = null;
            }
        })();// END ThumbsUp
    }

    return {
        ProcessInput: ProcessInput
    }
});

﻿define('Human Input Recognition and Processing/Hand Gestures/Two Hand Gestures/TwoHandGestureDetection',['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper'], function (bus, hh, fh) {
    function ProcessInput(data, hands, ActiveGesturesDictionary) {

        var source = 'Efficio Gesture Grimoire';
        var dictionary = 'TwoHandGesture';

        if (!ActiveGesturesDictionary[dictionary]) {
            ActiveGesturesDictionary[dictionary] = {};
        }

        (function BothHandsNeutral() {
            var gestureName = 'BothHandsNeutral'
            var neutrals = [hh.Neutral(hands[0]), hh.Neutral(hands[1])]

            if (neutrals[0] && neutrals[1]) {
                if (!ActiveGesturesDictionary[dictionary][gestureName]) {
                    ActiveGesturesDictionary[dictionary][gestureName] = {
                        StartTime: new Date()
                    }
                }

                var hand0Position = hands[0].palmPosition;
                var hand1Position = hands[1].palmPosition;
                var x2 = hand1Position[0];
                var y2 = hand1Position[1];
                var z2 = hand1Position[2];
                var x1 = hand0Position[0];
                var y1 = hand0Position[1];
                var z1 = hand0Position[2];

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        neutrals: neutrals,
                        distance: Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1)),
                        midpoint: [(x2 - x1) / 2, (y2 - y1) / 2, (z2 - z1) / 2],
                        gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][gestureName].StartTime - new Date()) / 1000)
                    }
                });
            }
            else {
                ActiveGesturesDictionary[dictionary][gestureName] = null;
            }
        })();// END Both Hands Neutral

        (function BothHandsNeutral() {
            var gestureName = 'BothHandsPronation'
            var pronations = [hh.Pronation(hands[0]), hh.Pronation(hands[1])]

            if (pronations[0] && pronations[1]) {
                if (!ActiveGesturesDictionary[dictionary][gestureName]) {
                    ActiveGesturesDictionary[dictionary][gestureName] = {
                        StartTime: new Date()
                    }
                }
                var hand0Position = hands[0].palmPosition;
                var hand1Position = hands[1].palmPosition;
                var x2 = hand1Position[0];
                var y2 = hand1Position[1];
                var z2 = hand1Position[2];
                var x1 = hand0Position[0];
                var y1 = hand0Position[1];
                var z1 = hand0Position[2];

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: gestureName,
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        neutrals: pronations,
                        distance: Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1)),
                        midpoint: [(x2 - x1) / 2, (y2 - y1) / 2, (z2 - z1) / 2],
                        gestureLength: Math.abs((ActiveGesturesDictionary[dictionary][gestureName].StartTime - new Date()) / 1000)
                    }
                });
            }
            else {
                ActiveGesturesDictionary[dictionary][gestureName] = null;
            }
        })();// END Both Hand Pronation
    }

    return {
        ProcessInput: ProcessInput
    }
});

﻿define('Human Input Recognition and Processing/Hand Gestures/HandGestureDetectionHandler',['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper'], function (bus, hh) {
    function ProcessInput(data, ActiveGesturesDictionary) {
        var source = 'Efficio Gesture Grimoire';
        var channel = 'Input.Processed.Efficio';

        // Check if there is any input and if the input contains hands
        if (data.input && data.input.hands) {

            var hands = data.input.hands;

            // Check if any hands are present
            (function NoHandsDetected() {
                var gestureName = 'NoHandsDetected'

                if (hands.length === 0) {
                    if (!ActiveGesturesDictionary[gestureName]) {
                        ActiveGesturesDictionary[gestureName] = {
                            StartTime: new Date()
                        }
                    }

                    bus.publish({
                        channel: channel,
                        topic: gestureName,
                        source: source,
                        data: {
                            message: 'No hands detected',
                            gestureLength: Math.abs((ActiveGesturesDictionary[gestureName].StartTime - new Date()) / 1000)
                        }
                    });

                    // Clear gesture dictionary for one and two hand gestures
                    ActiveGesturesDictionary['OneHandGesture'] = null;
                    ActiveGesturesDictionary['TwoHandGesture'] = null;
                    
                    // No need for processing any further
                    return;
                }
                else {
                    ActiveGesturesDictionary[gestureName] = null;
                }
            })();

            // Check if one hand is present
            (function OneHandDetected() {
                if (hands.length === 1) {
                    var side = hh.GetSide(hands[0]);
                    var gestureName = 'OneHandDetected'

                    if (!ActiveGesturesDictionary[gestureName]) {
                        ActiveGesturesDictionary[gestureName] = {
                            StartTime: new Date()
                        }
                    }

                    var oppositeHand = side === 'Right' ? 'Left' : 'Right'

                    // Clear other hand gesture dictionary entries
                    if (ActiveGesturesDictionary['OneHandGesture']) {
                        ActiveGesturesDictionary['OneHandGesture'][oppositeHand] = null;
                    }

                    // Clear two hand gesture dictionary entries
                    if (ActiveGesturesDictionary['TwoHandGesture']) {
                        ActiveGesturesDictionary['TwoHandGesture'] = null;
                    }

                    // Send Message saying that a hand was detected
                    bus.publish({
                        channel: channel,
                        topic: gestureName,
                        source: source,
                        data: {
                            handCount: hands[0],
                            gestureLength: Math.abs((ActiveGesturesDictionary[gestureName].StartTime - new Date()) / 1000)
                        }
                    });
                }
                else {
                    ActiveGesturesDictionary[gestureName] = null;
                }
            })();

            // Check if any hand present
            if (hands.length > 0) {

                // Process Gestures for each hand
                hands.forEach(function (hand) {

                    // Send Message saying what hand was detected
                    var type = hand.type;
                    bus.publish({
                        channel: channel,
                        topic: type + 'HandDetected',
                        source: source,
                        data: {
                            hand: hand
                        }
                    });

                    // Send data to the one hand gesture detection library
                    require(['Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandGestureDetection'], function (ohgd) {
                        ohgd.ProcessInput(data, hand, ActiveGesturesDictionary);
                    });
                });

                // Send Message saying that two hands were detected
                bus.publish({
                    channel: channel,
                    topic: 'TwoHandDetected',
                    source: source,
                    data: {
                    }
                });

                if (hands.length === 2) {
                    // Send data to the two hand gesture detection library
                    require(['Human Input Recognition and Processing/Hand Gestures/Two Hand Gestures/TwoHandGestureDetection'], function (thgd) {
                        thgd.ProcessInput(data, hands, ActiveGesturesDictionary);
                    });
                }
            }
        }
    }


    return {
        ProcessInput: ProcessInput
    }
})
;
﻿define('Human Input Recognition and Processing/EfficioGestureGrimoire',['postal'], function (bus) {
    var source = 'Efficio Gesture Grimoire';
    var ActiveGesturesDictionaryCopy = {};

    function DetectPredefinedGestures(data, envelope) {
        var trackingType = data.trackingType || '';

        switch (trackingType) {
            case 'Hands': {
                require(['Human Input Recognition and Processing/Hand Gestures/HandGestureDetectionHandler'], function (hgdh) {
                    hgdh.ProcessInput(data, ActiveGesturesDictionaryCopy)
                });
                break;
            }
            case 'Body': {
                // Body tracking library here
                break;
            }
            case 'Face': {
                // Face tracking library here
                break;
            }
            case 'Brain': {
                // Brain tracking library here
                break;
            }
        }
    }



    return {
        Initialize: function (ActiveGesturesDictionary) {
            ActiveGesturesDictionaryCopy = ActiveGesturesDictionary;
        },

        ProcessInput: function (data, envelope) {
            DetectPredefinedGestures(data, envelope);
        }
    }
});

﻿define('Human Input Recognition and Processing/HumanInputRecognitionAndProcessing',['postal'], function (bus) {
    return {
        Initialize: function () {
            var ActiveGesturesDictionary = {};

            require(['Human Input Recognition and Processing/CustomGestureLibrariesAccess'], function (customGestureLibraries) {
                customGestureLibraries.Initialize(ActiveGesturesDictionary);

                bus.subscribe({
                    channel: "Input.Raw",
                    topic: "*",
                    callback: function (data, envelope) {
                        customGestureLibraries.ProcessInput(data, envelope);
                    }
                });
            }), function (err) {
                bus.publish({
                    channel: 'UserNotification',
                    topic: 'Warn',
                    source: source,
                    data: {
                        message: 'No custom gesture library configured'
                    }
                });
            };

            require(['Human Input Recognition and Processing/EfficioGestureGrimoire'], function (efficioGestureLibrary) {
                efficioGestureLibrary.Initialize(ActiveGesturesDictionary);

                bus.subscribe({
                    channel: "Input.Raw",
                    topic: "*",
                    callback: function (data, envelope) {
                        efficioGestureLibrary.ProcessInput(data, envelope);
                    }
                });
            });

            //require(['Human Input Recognition and Processing/EfficioAudioGrimoire'], function (efficioAudioGrimoire) {
            //    efficioAudioGrimoire.Initialize();

            //    bus.subscribe({
            //        channel: "Input.Audio.Raw",
            //        topic: "*",
            //        callback: function (data, envelope) {
            //            efficioAudioGrimoire.ProcessInput(data, envelope);
            //        }
            //    });
            //});
        }
    }
});

﻿define('InternalScene',['THREE'], function () {
    var scene = new THREE.Scene();

    return {
        Initialize: function () {
        
        }, 
    
        Scene: scene
    }
});

﻿define('Asset Management and Inventory/AssetManager',['postal', 'InternalScene'], function (bus, internalScene) {
    var source = "Efficio Asset Manager"

    function CreateAsset(asset) {
        bus.publish({
            channel: "UserNotification",
            topic: "AssetCreated",
            source: source,
            data: {
                message: "Asset created with data: " + asset
            }
        });

        internalScene.Scene.add(asset);
    };

    function CreateAssets(assets) {

    };

    function RetrieveAsset(assetID) {

    };

    function RetrieveAssets(assetIDs) {

    };

    function RetrieveAllAssets() {

    };

    function RetrieveAllAssetIDs() {

    };

    function UpdateAsset(asset) {
        var oldAsset = internalScene.Scene.getObjectById(asset.id);

        internalScene.Scene.remove(oldAsset);
        internalScene.Scene.add(asset);

        asset = internalScene.Scene.getObjectById(asset.id);

        bus.publish({
            channel: "UserNotification",
            topic: "AssetUpdated",
            source: source,
            data: {
                message: source + " - Asset Updated: \nID: " + asset.id + "\nPosition: (" + asset.position.x + " , " + asset.position.y + ", " + asset.position.z + ")" + "\nScale: (" + asset.scale.x + " , " + asset.scale.y + ", " + asset.scale.z + ")"
            }
        });
    };

    function UpdateAssets(assets) {

    };

    function DeleteAsset(assetID) {

    };

    function DeleteAssets(assetIDs) {

    };

    function DeleteAllAssets() {

    };

    function GetValueForProperty(property, data) {
        switch (property) {
            case "ClosestAsset":
                {
                    return GetClosestAsset(data);
                }
        }
    }

    function GetClosestAsset(data) {
        if (data.location === null) {
            bus.publish({
                channel: "Exception.Efficio",
                topic: "GetClosestAsset",
                source: source,
                data: {
                    message: "GetClosestAsset function requires location argument"
                }
            });
        }
        return "Asset closest to point (" + data.Location.x + ", " + data.Location.y + ", " + data.Location.z + ")"
    }

    return {
        Initialize: function () {
            if (typeof window != 'undefined') {
                //var http = new XMLHttpRequest();
                //http.open('HEAD', '/debug.html', false);
                //http.send();

                //if (http.status != 404) {
                //    var params = [
                //        'height=' + screen.height,
                //        'width=' + screen.width,
                //        'fullscreen=yes' // only works in IE, but here for completeness
                //    ].join(',');

                //    window.open('/debug.html', 'AMI Debugger', params);
                //}
            }
        },

        CreateAsset: CreateAsset,

        CreateAssets: CreateAssets,

        RetrieveAsset: RetrieveAsset,

        RetrieveAssets: RetrieveAssets,

        RetrieveAllAssets: RetrieveAllAssets,

        RetrieveAllAssetIDs: RetrieveAllAssetIDs,

        UpdateAsset: UpdateAsset,

        UpdateAssets: UpdateAssets,

        DeleteAsset: DeleteAsset,

        DeleteAssets: DeleteAssets,

        DeleteAllAssets: DeleteAllAssets,

        GetValueForProperty: GetValueForProperty,

    }
});

﻿define('Constraints Engine/ConstraintsEngine',['postal', 'Asset Management and Inventory/AssetManager'], function (bus, ami) {
    var source = "Efficio Constraints Engine";
    var violated = false;

    var subscriptions = new Array();

    function RegisterSubscriber(subscription) {
        subscriptions.push(subscription);
    }

    function CheckConstraints(data) {
        //if (violated) {
        //    console.log('Constraints violated, changes not reflected internally.')
        //}
        //else {
        //    console.log('Constraints not violated, changes reflected internally.')
        //}

        return true;
    }

    return{
        Initialize: function () {

        }
    };
});

﻿define('Command Issuance and Control/CommandIssuanceAndControl',['postal', 'Asset Management and Inventory/AssetManager'], function (bus, ami) {
    return {
        Initialize: function () {
            var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
            var ARGUMENT_NAMES = /([^\s,]+)/g;

            function getParamNames(func) {
                var fnStr = func.toString().replace(STRIP_COMMENTS, '');
                var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
                if (result === null)
                    result = [];
                return result;
            }

            ActionToFunctionMapping.ActionMappings.forEach(function (mapping) 
            {
                bus.subscribe({
                    channel: mapping.Source,
                    topic: mapping.Topic,
                    callback: function (data, envelope) {
                        var func = mapping.Action;

                        if (typeof func != 'function') {
                            func = ActionToFunctionMapping.Bridge[mapping.Action];
                        }

                        // Get method parameters
                        var functionParameters = getParamNames(func);

                        var argMapping = {};

                        // Create args for function call
                        var args = [];

                        if (mapping.Arguments) {
                            functionParameters.forEach(function (param) {
                                var params = mapping.Arguments.filter(function (argument) {
                                    return argument.MapTo === param;
                                });

                                if (params.length > 0) {
                                    var value;

                                    if (params[0].Source && params[0].Source === 'AssetManager') {
                                        value = ami.GetValueForProperty(params[0].Name, data);
                                    }
                                    else {
                                        value = data[params[0].Name];
                                    }

                                    args.push(value);
                                }
                                else {
                                    args.push(null);
                                }
                            });
                        }
                        else {
                            args = [data];
                        }
                       
                        func.apply(null, args);
                    }
                })
            });
        }
    };
});

﻿define('Logging/SystemNotificationListener',['postal'], function (bus) {
    return {
        Initialize: function () {
            bus.subscribe({
                channel: "SystemNotification",
                topic: "*",
                callback: function (data, envelope) {
                    console.log(envelope.topic + ": " + data.message);
                }
            });
        }
    }
});

﻿define('Input/LeapMotion/LeapMotion',['postal', 'leapjs'], function (bus, Leap) {
    var source = 'Leap Motion';
    var trackingType = 'Hands';
    var controller;

    function configure(LeapConfiguration)
    {
        LeapConfiguration = {
            Host: LeapConfiguration.Host || 'localhost',
            Port: LeapConfiguration.Port || 6437,
            EnableGestures: LeapConfiguration.EnableGestures || false,
            FrameEventName: LeapConfiguration.FrameEventName || 'animationFrame',
            UseAllPlugins: LeapConfiguration.UseAllPlugins || false
        }

        return LeapConfiguration;
    }

    return {
        Initialize: function (LeapConfiguration) {

            // Load Configuration
            LeapConfiguration = configure(LeapConfiguration);
            
            // Create Controller
            controller = new Leap.Controller({
                host: LeapConfiguration.Host,
                port: LeapConfiguration.Port,
                enableGestures: LeapConfiguration.EnableGestures,
                frameEventName: LeapConfiguration.FrameEventName,
                useAllPlugins: LeapConfiguration.UseAllPlugins
            });

            // Register Leap's native gesture recognition
            controller.on("gesture", function (gesture) {
                if (gesture.state == "stop") {
                    bus.publish({
                        channel: 'Input.Raw',
                        topic: 'Gesture',
                        source: source,
                        data: {
                            name: gesture.type,
                            gesture: gesture
                        }
                    });
                }
            });

            // Sends message when controller is connected
            controller.on("connect", function () {
                bus.publish({
                    channel: 'Devices',
                    topic: 'Connected',
                    source: source,
                    data: {
                        name: source,
                        device: Leap,
                        controller: controller,
                        test: 'test'
                    }
                });
            });

            controller.connect();
        },

        Start: function () {

            // Listens for input from device
            controller.loop(function (frame) {
                if (frame.valid) {
                    bus.publish({
                        channel: 'Input.Raw',
                        topic: 'Leap',
                        source: source,
                        data: {
                            trackingType: trackingType,
                            input: frame
                        }
                    });
                }
            });
        }
    }
});

﻿define('Input/Microphone/Microphone',['postal', 'annyang'], function (bus, annyang) {

    var source = 'Microphone';
    var recognition;
    var autoRestart = true;
    var lastStartedAt = 0;

    return {
        Intitialize: function () {

            if (typeof annyang != 'undefined') {
                
                if (typeof ActionToFunctionMapping.AudioCommands != 'undefined') {
                    // Add our commands to annyang
                    annyang.addCommands(ActionToFunctionMapping.AudioCommands);
                }
            }
        },
        Start: function () {
            if (annyang) {
                annyang.start();

                bus.publish({
                    channel: 'Devices',
                    topic: 'Connected',
                    source: source,
                    data: {
                        name: source,
                        test: 'test'
                    }
                });
            }
        }
    }
});

﻿define('Efficio',[
    'Message Bus/MessageBus',
    'Human Input Recognition and Processing/HumanInputRecognitionAndProcessing',
    'Asset Management and Inventory/AssetManager',
    'Constraints Engine/ConstraintsEngine',
    'Command Issuance and Control/CommandIssuanceAndControl',
    'InternalScene',
    'Logging/SystemNotificationListener',
    //'Sequence Execution and Action Scheduling/CollisionDetectionAndGravitySimulation',
],

function (bus, hirp, ami, constraintsEngine, comm, internalScene, sysNotificationListener) {
    var leapmotion;
    var microphone;

    function configure(EfficioConfiguration) {
        EfficioConfiguration.devices = EfficioConfiguration.devices || { microphone: false, kinect: false, leapmotion: false };
        EfficioConfiguration.debug = EfficioConfiguration.debug || false;
    }

    return {
        Initialize: function (EfficioConfiguration) {
            configure(EfficioConfiguration);
            bus.Initialize();
            hirp.Initialize();
            ami.Initialize();
            constraintsEngine.Initialize();
            comm.Initialize();
            internalScene.Initialize();
            sysNotificationListener.Initialize();

            if (EfficioConfiguration.devices.leapmotion) {
                require(['Input/LeapMotion/LeapMotion'], function (leap) {
                    leapmotion = leap;
                    leapmotion.Initialize(EfficioConfiguration.devices.leapmotion);
                    leapmotion.Start();
                });
            }

            if (EfficioConfiguration.devices.microphone) {
                require(['Input/Microphone/Microphone'], function (mic) {
                    microphone = mic;
                    microphone.Intitialize();
                    microphone.Start();
                });
            }
        },
        Start: function () {

        }
    }
});

﻿if (typeof THREE === 'object') {
    define('THREE', function () { return THREE; });
}

if (typeof Leap === 'function') {
    define('leapjs', function () { return Leap; });
}

require(["Efficio"], function (Efficio) {
    Efficio.Initialize(EfficioConfiguration);
    Efficio.Start();
});

define("main", function(){});

