define('Message Bus/MessageBus',['postal'], function (bus) {
    return {
        Initialize: function () {
            // Any bus configuration here
        },
        Bus: bus
    }
});

﻿define('Human Input Recognition and Processing/CustomGestureLibrariesAccess',['postal'], function (bus) {
    var source = 'Custom Gesture Libraries';

    function LoadCustomGestures() {
        // Custom Gestures created by the user will be loaded here
    }

    function DetectCustomGestures(data, envelope) {
        var libraryName = 'custom library 1';
        var gestureName = 'my custom gesture';
        var gestureData = 'my custom gesture data';

        // If custom gesture is detected
        if (data.input === 'BVH representation of a custom gesture') {

            bus.publish({
                channel: "Input.Processed.Custom." + libraryName,
                topic: gestureName,
                source: source,
                data: gestureData
            });
        }
    }

    return {
        Initialize: function () {
            LoadCustomGestures();
        },
        ProcessInput: function (data, envelope) {

            // Where input is processed and Custom Gestures are published on the channel
            DetectCustomGestures(data, envelope);
        }
    }
})
;
﻿define('Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper',[],function () {
    function GetSide(hand) {
        return hand.type === 'right' ? 'Right' : 'Left';
    }

    function GetAngle(hand) {
        return hand.direction[1];
    }

    return {
        GetSide: GetSide,
        GetAngle: GetAngle
    }
})
;
﻿define('Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper',[],function () {
    var fingerCountLabelsMap = ["Zero", "One", "Two", "Three", "Four", "Five"];
    var fingerNameLabelMap = ["Thumb", "Index", "Middle", "Ring", "Pinky"];

    function GetExtendedFingers(hand){
        return hand.fingers.filter(function (finger) {
            return finger.extended;
        });
    }

    function GetExtendedFingersIndicies(hand) {
        return hand.fingers.filter(function (finger) {
            return finger.extended;
        }).map(function (finger) {
            return finger.type
        });
    }

    function GetFingerLabel(fingerIndex) {
        return fingerNameLabelMap[fingerIndex];
    }

    function GetExtendedFingersCount(hand) {
        return GetExtendedFingers(hand).length;
    }

    function GetExtendedFingersCountLabel(hand) {
        return fingerCountLabelsMap[GetExtendedFingersCount(hand)];
    }

    function AreRequisiteFingersExtended(hand, neededFingersArray) {
        var extendedFingers = GetExtendedFingers(hand);

        return extendedFingers.filter(function (n) {
            return neededFingersArray.indexOf(n) != -1
        }).length === neededFingersArray.length;
    }

    return {
        GetExtendedFingers: GetExtendedFingers,
        GetExtendedFingersIndicies: GetExtendedFingersIndicies,
        GetFingerLabel: GetFingerLabel,
        GetExtendedFingersCount: GetExtendedFingersCount,
        GetExtendedFingersCountLabel: GetExtendedFingersCountLabel,
        AreRequisiteFingersExtended: AreRequisiteFingersExtended
    }
})
;
﻿define('Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandGestureDetection',['postal', 'Human Input Recognition and Processing/Hand Gestures/Helpers/HandHelper', 'Human Input Recognition and Processing/Hand Gestures/Helpers/FingerHelper'], function (bus, hh, fh) {
    function ProcessInput(data, hand) {
        var source = 'Efficio Gesture Grimoire';

        // Hand information
        var side = hh.GetSide(hand);
        var angle = hh.GetAngle(hand);

        // Finger information
        var extendedFingerCount = fh.GetExtendedFingersCount(hand);
        var extendedFingerCountLabel = fh.GetExtendedFingersCountLabel(hand);
        var extendedFingersIndicies = fh.GetExtendedFingersIndicies(hand);
        var extendedFingers = fh.GetExtendedFingers(hand);

        /*
          Name:           {Side} Hand {Count} Fingers Extended
   
          Outputs:        RightHandZeroFingersExtended
                          RightHandOneFingersExtended
                          RightHandTwoFingersExtended
                          RightHandThreeFingersExtended
                          RightHandFourFingersExtended
                          RightHandFiveFingersExtended
                          LeftHandZeroFingersExtended
                          LeftHandOneFingersExtended
                          LeftHandTwoFingersExtended
                          LeftHandThreeFingersExtended
                          LeftHandFourFingersExtended
                          LeftHandFiveFingersExtended
           
          Description:    Informs consumer how many fingers fingers are extended and on which hand 
       */
        (function SideHandCountFingersExtended() {
            bus.publish({
                channel: "Input.Processed.Efficio",
                topic: side + 'Hand' + extendedFingerCountLabel + 'FingersExtended',
                source: source,
                data: {
                    input: data,
                    hand: hand,
                    extendedFingers: extendedFingersIndicies
                }
            });
        })(); // END {Side} Hand {Count} Fingers Extended

        /*
           Name:           {Side} Hand {Finger} Extended
   
           Outputs:        RightHandThumbFingerExtended
                           RightHandIndexFingerExtended
                           RightHandMiddleFingerExtended
                           RightHandRingFingerExtended
                           RightHandPinkyFingerExtended
                           LeftHandThumbFingerExtended
                           LeftHandIndexFingerExtended
                           LeftHandMiddleFingerExtended
                           LeftHandRingFingerExtended
                           LeftHandPinkyFingerExtended
           
           Description:    Informs consumer which fingers are extended and on which hand 
       */
        (function SideHandFingerDetected() {
            extendedFingersIndicies.forEach(function (index) {
                var fingerName = fh.GetFingerLabel(index);

                bus.publish({
                    channel: "Input.Processed.Efficio",
                    topic: side + 'Hand' + fingerName + 'FingerExtended',
                    source: source,
                    data: {
                        input: data,
                        hand: hand,
                        finger: index,
                    }
                });
            })

        })(); // END {Side} Hand {Finger} Extended

        /*
            Name:           {Side} Hand {Direction} Detected
    
            Outputs:        RightHandUpDetected
                            RightHandDownDetected
                            LeftHandUpDetected
                            LeftHandDownDetected
            
            Description:    Informs consumer which hand is in view, if four fingers are extended, and if the fingers are above or below the palm.
                            {Side} 
        */
        (function SideHandDirectionDetected() {
            var requisiteFingers = [1, 2, 3, 4];
            if (fh.AreRequisiteFingersExtended(hand, requisiteFingers)) {

                // Determine direction
                var direction = '';
                if (angle > .5) {
                    direction = 'Up'
                }
                else {
                    if (angle < .2) {
                        direction = 'Down'
                    }
                }

                if (direction != '') {
                    bus.publish({
                        channel: "Input.Processed.Efficio",
                        topic: side + 'Hand' + direction + 'Detected',
                        source: source,
                        data: {
                            message: side + ' hand ' + direction + ' direction detected.'
                        }
                    });
                }
            }
        })();// END {Side} Hand {Direction} Detected
    }

    return {
        ProcessInput: ProcessInput
    }
});

﻿define('Human Input Recognition and Processing/Hand Gestures/Two Hand Gestures/TwoHandGestureDetection',['postal'], function (bus) {
    function ProcessInput(data, hands) {

    }

    return {
        ProcessInput: ProcessInput
    }
});

﻿define('Human Input Recognition and Processing/Hand Gestures/HandGestureDetectionHandler',['postal'], function (bus) {
    function ProcessInput(data) {
        var source = 'Efficio Gesture Grimoire';
        var channel = 'Input.Processed.Efficio';

        // Check if there is any input and if the input contains hands
        if (data.input && data.input.hands) {

            var hands = data.input.hands;

            // Check if any hands are present
            if (hands.length === 0) {
                bus.publish({
                    channel: channel,
                    topic: 'NoHandsDetected',
                    source: source,
                    data: {
                        message: 'No hands detected'
                    }
                });

                // No need for processing any further
                return;
            }

            // Check if one hand is present
            if (hands.length === 1) {

                // Send Message saying that a hand was detected
                bus.publish({
                    channel: channel,
                    topic: 'OneHandDetected',
                    source: source,
                    data: {
                        handCount: hands[0]
                    }
                });
            }

            // Check if any hand present
            if (hands.length > 0) {

                // Process Gestures for each hand
                hands.forEach(function (hand) {

                    // Send Message saying what hand was detected
                    var type = hand.type;
                    bus.publish({
                        channel: channel,
                        topic: type + 'HandDetected',
                        source: source,
                        data: {
                            hand: hand
                        }
                    });

                    // Send data to the one hand gesture detection library
                    require(['Human Input Recognition and Processing/Hand Gestures/One Hand Gestures/OneHandGestureDetection'], function (ohgd) {
                        ohgd.ProcessInput(data, hand);
                    });
                });

                // Send Message saying that two hands were detected
                bus.publish({
                    channel: channel,
                    topic: 'TwoHandDetected',
                    source: source,
                    data: {
                    }
                });

                // Send data to the two hand gesture detection library
                require(['Human Input Recognition and Processing/Hand Gestures/Two Hand Gestures/TwoHandGestureDetection'], function (thgd) {
                    thgd.ProcessInput(data, hands);
                });
            }
        }
    }

    return {
        ProcessInput: ProcessInput
    }
})
;
﻿define('Human Input Recognition and Processing/EfficioGestureGrimoire',['postal'], function (bus) {
    var source = 'Efficio Gesture Grimoire';

    function DetectPredefinedGestures(data, envelope) {
        var trackingType = data.trackingType || '';

        switch (trackingType) {
            case 'Hands': {
                require(['Human Input Recognition and Processing/Hand Gestures/HandGestureDetectionHandler'], function (hgdh) {
                    hgdh.ProcessInput(data)
                });
                break;
            }
            case 'Body': {
                // Body tracking library here
                break;
            }
            case 'Face': {
                // Face tracking library here
                break;
            }
            case 'Brain': {
                // Brain tracking library here
                break;
            }
        }
    }



    return {
        Initialize: function () {
            
        },

        ProcessInput: function (data, envelope) {
            DetectPredefinedGestures(data, envelope);
        }
    }
});

﻿define('Human Input Recognition and Processing/EfficioAudioGrimoire',['postal'], function (bus) {
    var source = 'Efficio Audio Grimoire';

    function CleanseMessage(message) {
        while (message.split('')[0] === ' ') {
            message = message.substring(1, message.lenght);
        }

        while (message.split('')[message.lenght] === ' ') {
            message = message.substring(0, message.lenght - 1);
        }

        return message.toUpperCase();
    }

    function DetectPhrases(data, envelope) {

        var message = CleanseMessage(data.message);

        if (message === 'HELLO') {
            bus.publish({
                channel: "Input.Audio.Processed.Efficio",
                topic: 'Hello',
                source: source,
                data: {
                    message: message
                }
            });
        }

        if (message === 'next'.toUpperCase()) {
            bus.publish({
                channel: "Input.Audio.Processed.Efficio",
                topic: 'Next',
                source: source,
                data: {
                    message: message
                }
            });
        }

        if (message === 'last'.toUpperCase()) {
            bus.publish({
                channel: "Input.Audio.Processed.Efficio",
                topic: 'Last',
                source: source,
                data: {
                    message: message
                }
            });
        }

        if (message === 'About'.toUpperCase()) {
            bus.publish({
                channel: "Input.Audio.Processed.Efficio",
                topic: 'About',
                source: source,
                data: {
                    message: message
                }
            });
        }

        if (message === 'Samples'.toUpperCase()) {
            bus.publish({
                channel: "Input.Audio.Processed.Efficio",
                topic: 'Samples',
                source: source,
                data: {
                    message: message
                }
            });
        }

        if (message === 'Download'.toUpperCase()) {
            bus.publish({
                channel: "Input.Audio.Processed.Efficio",
                topic: 'Download',
                source: source,
                data: {
                    message: message
                }
            });
        }

        if (message === 'Home'.toUpperCase()) {
            bus.publish({
                channel: "Input.Audio.Processed.Efficio",
                topic: 'Home',
                source: source,
                data: {
                    message: message
                }
            });
        }

        bus.publish({
            channel: "Input.Audio.Processed.Efficio",
            topic: 'Unmapped',
            source: source,
            data: {
                message: message
            }
        });

        // Spanish LOL
        if (message === 'Contact'.toUpperCase()) {
            bus.publish({
                channel: "Input.Audio.Processed.Efficio",
                topic: 'Contact',
                source: source,
                data: {
                    message: message
                }
            });
        }

        if (message === 'siguiente'.toUpperCase()) {
            bus.publish({
                channel: "Input.Audio.Processed.Efficio",
                topic: 'Next',
                source: source,
                data: {
                    message: message
                }
            });
        }

        if (message === 'último'.toUpperCase()) {
            bus.publish({
                channel: "Input.Audio.Processed.Efficio",
                topic: 'Last',
                source: source,
                data: {
                    message: message
                }
            });
        }
    }

    return {
        Initialize: function () {

        },

        ProcessInput: function (data, envelope) {
            // Where input is processed and Custom Gestures are published on the channel
            DetectPhrases(data, envelope);
        }
    }
});

﻿define('Human Input Recognition and Processing/HumanInputRecognitionAndProcessing',['postal'], function (bus) {
    return {
        Initialize: function () {
            require(['Human Input Recognition and Processing/CustomGestureLibrariesAccess'], function (customGestureLibraries) {
                customGestureLibraries.Initialize();

                bus.subscribe({
                    channel: "Input.Raw",
                    topic: "*",
                    callback: function (data, envelope) {
                        customGestureLibraries.ProcessInput(data, envelope);
                    }
                });
            }), function (err) {
                bus.publish({
                    channel: 'UserNotification',
                    topic: 'Warn',
                    source: source,
                    data: {
                        message: 'No custom gesture library configured'
                    }
                });
            };

            require(['Human Input Recognition and Processing/EfficioGestureGrimoire'], function (efficioGestureLibrary) {
                efficioGestureLibrary.Initialize();

                bus.subscribe({
                    channel: "Input.Raw",
                    topic: "*",
                    callback: function (data, envelope) {
                        efficioGestureLibrary.ProcessInput(data, envelope);
                    }
                });
            });

            require(['Human Input Recognition and Processing/EfficioAudioGrimoire'], function (efficioAudioGrimoire) {
                efficioAudioGrimoire.Initialize();

                bus.subscribe({
                    channel: "Input.Audio.Raw",
                    topic: "*",
                    callback: function (data, envelope) {
                        efficioAudioGrimoire.ProcessInput(data, envelope);
                    }
                });
            });
        }
    }
});

﻿define('InternalScene',['THREE'], function () {
    var scene = new THREE.Scene();

    return {
        Initialize: function () {
        
        }, 
    
        Scene: scene
    }
});

﻿define('Asset Management and Inventory/AssetManager',['postal', 'InternalScene'], function (bus, internalScene) {
    var source = "Efficio Asset Manager"

    function CreateAsset(asset) {
        bus.publish({
            channel: "UserNotification",
            topic: "AssetCreated",
            source: source,
            data: {
                message: "Asset created with data: " + asset
            }
        });

        internalScene.Scene.add(asset);
    };

    function CreateAssets(assets) {

    };

    function RetrieveAsset(assetID) {

    };

    function RetrieveAssets(assetIDs) {

    };

    function RetrieveAllAssets() {

    };

    function RetrieveAllAssetIDs() {

    };

    function UpdateAsset(asset) {
        var oldAsset = internalScene.Scene.getObjectById(asset.id);

        internalScene.Scene.remove(oldAsset);
        internalScene.Scene.add(asset);

        asset = internalScene.Scene.getObjectById(asset.id);

        bus.publish({
            channel: "UserNotification",
            topic: "AssetUpdated",
            source: source,
            data: {
                message: source + " - Asset Updated: \nID: " + asset.id + "\nPosition: (" + asset.position.x + " , " + asset.position.y + ", " + asset.position.z + ")" + "\nScale: (" + asset.scale.x + " , " + asset.scale.y + ", " + asset.scale.z + ")"
            }
        });
    };

    function UpdateAssets(assets) {

    };

    function DeleteAsset(assetID) {

    };

    function DeleteAssets(assetIDs) {

    };

    function DeleteAllAssets() {

    };

    function GetValueForProperty(property, data) {
        switch (property) {
            case "ClosestAsset":
                {
                    return GetClosestAsset(data);
                }
        }
    }

    function GetClosestAsset(data) {
        if (data.location === null) {
            bus.publish({
                channel: "Exception.Efficio",
                topic: "GetClosestAsset",
                source: source,
                data: {
                    message: "GetClosestAsset function requires location argument"
                }
            });
        }
        return "Asset closest to point (" + data.Location.x + ", " + data.Location.y + ", " + data.Location.z + ")"
    }

    return {
        Initialize: function () {
            if (typeof window != 'undefined') {
                //var http = new XMLHttpRequest();
                //http.open('HEAD', '/debug.html', false);
                //http.send();

                //if (http.status != 404) {
                //    var params = [
                //        'height=' + screen.height,
                //        'width=' + screen.width,
                //        'fullscreen=yes' // only works in IE, but here for completeness
                //    ].join(',');

                //    window.open('/debug.html', 'AMI Debugger', params);
                //}
            }
        },

        CreateAsset: CreateAsset,

        CreateAssets: CreateAssets,

        RetrieveAsset: RetrieveAsset,

        RetrieveAssets: RetrieveAssets,

        RetrieveAllAssets: RetrieveAllAssets,

        RetrieveAllAssetIDs: RetrieveAllAssetIDs,

        UpdateAsset: UpdateAsset,

        UpdateAssets: UpdateAssets,

        DeleteAsset: DeleteAsset,

        DeleteAssets: DeleteAssets,

        DeleteAllAssets: DeleteAllAssets,

        GetValueForProperty: GetValueForProperty,

    }
});

﻿define('Constraints Engine/ConstraintsEngine',['postal', 'Asset Management and Inventory/AssetManager'], function (bus, ami) {
    var source = "Efficio Constraints Engine";
    var violated = false;

    var subscriptions = new Array();

    function RegisterSubscriber(subscription) {
        subscriptions.push(subscription);
    }

    function CheckConstraints(data) {
        //if (violated) {
        //    console.log('Constraints violated, changes not reflected internally.')
        //}
        //else {
        //    console.log('Constraints not violated, changes reflected internally.')
        //}

        return true;
    }

    return{
        Initialize: function () {

        }
    };
});

﻿define('Command Issuance and Control/CommandIssuanceAndControl',['postal', 'Asset Management and Inventory/AssetManager'], function (bus, ami) {
    var ThreeDSystem;

    var subscriptions = new Array();

    function RegisterSubscriber(subscription) {
        subscriptions.push(subscription);
    }

    function CallDynamicFunction(func, data, returnedFromFunction) {
        return ThreeDSystem[func](data, returnedFromFunction);
    }

    return {
        Initialize: function () {
            
            var config = ActionToFunctionMapping;
            ThreeDSystem = window[config.PluginName.substring(0, config.PluginName.length - 3)];

            config.ActionMappings.forEach(function (mapping) {
                RegisterSubscriber(
                    bus.subscribe({

                        channel: mapping.Source,
                        topic: mapping.Topic,
                        callback: function (data, envelope) {

                            var returnValues = {};
                            returnValues.publishResults = true;

                            if (mapping.Arguments) {
                                var variableDeclaration = '';
                                var dynamicJavascript = '';

                                mapping.Arguments.forEach(function (argMapping) {
                                    variableDeclaration = variableDeclaration + 'var ' + argMapping.MapTo

                                    if (argMapping.Source === 'Gesture') {
                                        variableDeclaration = variableDeclaration + ' = data["' + argMapping.Name + '"];\n';

                                    }

                                    if (argMapping.Source === 'AssetManager') {
                                        variableDeclaration = variableDeclaration + ' = ami.GetValueForProperty("' + argMapping.Name + '", data);\n';
                                    }

                                    if (argMapping.Source === 'Device') {
                                        variableDeclaration = variableDeclaration + ' = data["' + argMapping.Name + '"];\n';
                                    }

                                    dynamicJavascript = dynamicJavascript + argMapping.MapTo + ', '
                                });

                                dynamicJavascript = 'ThreeDSystem[mapping.Action](' + dynamicJavascript.substring(0, dynamicJavascript.length - 2) + ', returnValues)';

                                eval(variableDeclaration);
                                eval(dynamicJavascript);
                            }
                            else {
                                //This is the actual call to the external tool's plugin (i.e. SketchUp.js)
                                CallDynamicFunction(mapping.Action, data, returnValues);
                            }

                            if (mapping.Result) {
                                mapping.Result.forEach(function (result) {
                                    var data = new Object();

                                    if (result.Data) {
                                        for (key in result.Data) {
                                            data[key] = returnValues[result.Data[key]];
                                        }
                                    }

                                    if (returnValues.publishResults) {
                                        bus.publish({
                                            channel: result.Channel,
                                            topic: result.Topic,
                                            source: mapping.Source,
                                            data: data
                                        });
                                    }
                                });
                            }
                        }
                    }));
            });
        }
    };
});

﻿define('Logging/SystemNotificationListener',['postal'], function (bus) {
    return {
        Initialize: function () {
            bus.subscribe({
                channel: "SystemNotification",
                topic: "*",
                callback: function (data, envelope) {
                    console.log(envelope.topic + ": " + data.message);
                }
            });
        }
    }
});

﻿define('Input/LeapMotion/LeapMotion',['postal', 'leapjs'], function (bus, Leap) {
    var source = 'Leap Motion';
    var trackingType = 'Hands';
    var controller;

    function configure(LeapConfiguration)
    {
        LeapConfiguration = {
            Host: LeapConfiguration.Host || 'localhost',
            Port: LeapConfiguration.Port || 6437,
            EnableGestures: LeapConfiguration.EnableGestures || false,
            FrameEventName: LeapConfiguration.FrameEventName || 'animationFrame',
            UseAllPlugins: LeapConfiguration.UseAllPlugins || false
        }

        return LeapConfiguration;
    }

    return {
        Initialize: function (LeapConfiguration) {

            // Load Configuration
            LeapConfiguration = configure(LeapConfiguration);
            
            // Create Controller
            controller = new Leap.Controller({
                host: LeapConfiguration.Host,
                port: LeapConfiguration.Port,
                enableGestures: LeapConfiguration.EnableGestures,
                frameEventName: LeapConfiguration.FrameEventName,
                useAllPlugins: LeapConfiguration.UseAllPlugins
            });

            // Register Leap's native gesture recognition
            controller.on("gesture", function (gesture) {
                if (gesture.state == "stop") {
                    bus.publish({
                        channel: 'Input.Raw',
                        topic: 'Gesture',
                        source: source,
                        data: {
                            name: gesture.type,
                            gesture: gesture
                        }
                    });
                }
            });

            // Sends message when controller is connected
            controller.on("connect", function () {
                bus.publish({
                    channel: 'Devices',
                    topic: 'Connected',
                    source: source,
                    data: {
                        name: source,
                        device: Leap,
                        controller: controller
                    }
                });
            });

            controller.connect();
        },

        Start: function () {

            // Listens for input from device
            controller.loop(function (frame) {
                if (frame.valid) {
                    bus.publish({
                        channel: 'Input.Raw',
                        topic: 'Leap',
                        source: source,
                        data: {
                            trackingType: trackingType,
                            input: frame
                        }
                    });
                }
            });
        }
    }
});

﻿define('Input/Microphone/Microphone',['postal', 'annyang'], function (bus, annyang) {

    var source = 'Microphone';
    var recognition;
    var autoRestart = true;
    var lastStartedAt = 0;

    return {
        Intitialize: function () {

            if (typeof annyang != 'undefined') {
                
                if (typeof AudioCommands != 'undefined') {
                    // Add our commands to annyang
                    annyang.addCommands(AudioCommands);
                }
            }
        },
        Start: function () {
            if (annyang) {
                annyang.start();

                bus.publish({
                    channel: 'Devices',
                    topic: 'Connected',
                    source: source,
                    data: {
                        name : source,
                    }
                });
            }
        }
    }
});

﻿define('Efficio',[
    'Message Bus/MessageBus',
    'Human Input Recognition and Processing/HumanInputRecognitionAndProcessing',
    'Asset Management and Inventory/AssetManager',
    'Constraints Engine/ConstraintsEngine',
    'Command Issuance and Control/CommandIssuanceAndControl',
    'InternalScene',
    'Logging/SystemNotificationListener',
    //'Sequence Execution and Action Scheduling/CollisionDetectionAndGravitySimulation',
],

function (bus, hirp, ami, constraintsEngine, comm, internalScene, sysNotificationListener) {
    var leapmotion;
    var microphone;

    function configure(EfficioConfiguration) {
        EfficioConfiguration.devices = EfficioConfiguration.devices || { microphone: false, kinect: false, leapmotion: false };
        EfficioConfiguration.debug = EfficioConfiguration.debug || false;
    }

    return {
        Initialize: function (EfficioConfiguration) {
            configure(EfficioConfiguration);
            bus.Initialize();
            hirp.Initialize();
            ami.Initialize();
            constraintsEngine.Initialize();
            comm.Initialize();
            internalScene.Initialize();
            sysNotificationListener.Initialize();

            if (EfficioConfiguration.devices.leapmotion) {
                require(['Input/LeapMotion/LeapMotion'], function (leap) {
                    leapmotion = leap;
                    leapmotion.Initialize(EfficioConfiguration.devices.leapmotion);
                    leapmotion.Start();
                });
            }

            if (EfficioConfiguration.devices.microphone) {
                require(['Input/Microphone/Microphone'], function (mic) {
                    microphone = mic;
                    microphone.Intitialize();
                    microphone.Start();
                });
            }
        },
        Start: function () {

        }
    }
});

﻿if (typeof THREE === 'object') {
    define('THREE', function () { return THREE; });
}

if (typeof Leap === 'function') {
    define('leapjs', function () { return Leap; });
}

require(["Efficio"], function (Efficio) {
    Efficio.Initialize(EfficioConfiguration);
    Efficio.Start();
});

define("main", function(){});

